{"posts":[{"title":"线性代数","text":"线性代数笔记。 基础知识行列式 二阶行列式 $\\begin{vmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\\\ \\end{vmatrix} = a_{11}a_{22} - a_{12}a_{21}$ 三阶行列式 $ \\begin{vmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{vmatrix} = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} -a_{13}a_{22}a_{31} - a_{23}a_{32}a_{11} - a_{33}a_{12}a_{21}$ 对于更高阶的行列式，一般将行列式转为三角形，这样只用计算对角线的乘积即可。 余子式$n$阶行列式，把第$a_{ij}$所在的行列删除，留下的$n-1$阶行列式称为余子式，记为$M_{ij}$。 代数余子式代数余子式的$A_{ij} = -1^{i+j}M_{ij}$。 伴随矩阵代数余子式的转置称为伴随矩阵，只有方阵才有伴随矩阵，记为$A^*$。 伴随矩阵的性质： $AA^* = A^*A = |A|E$ $A^{-1} = \\frac{1}{|A|}A^*（存在A^{-1}）$ $(A^*)^{-1}=(A^{-1})^*=\\frac{1}{|A|}A$ $|A^*|=|A|^{n-1}$ $(kA)^*=k^{n-1}A^*$ 矩阵的逆$A^{-1} = \\frac{1}{|A|}A^*（存在A^{-1}）$ $A^{-1} = \\frac{1}{|A|}A^{*}=\\frac{1}{ad-bc}\\begin{bmatrix}d &amp;-b\\ -c &amp; a\\end{bmatrix}$ 例： $\\begin{bmatrix}1&-1\\\\1&1 \\end{bmatrix}^{-1} = \\frac{1}{2}\\begin{bmatrix}1&1\\\\-1&1 \\end{bmatrix}$ 线性代数的本质b站视频链接 什么是向量向量对于不同的学科有不一样的定义。 物理中的向量有长度和方向决定，长度和方向不变可以随意移动，它们表示的是同一个向量。 计算机中的向量更多的是对数据的抽象，可以根据面积和价格定义一个房子$\\begin{bmatrix}100m^2\\\\700000￥\\end{bmatrix}$。 数学中的向量可以是任意东西，只要保证两个向量的相加$\\vec v + \\vec w$以及数字和向量相乘$2\\vec v$是有意义的即可。 线性代数中的向量可以理解为一个空间中的箭头，这个箭头起点落在原点。如果空间中有许多的向量，可以点表示一个向量，即向量头的坐标。 向量的基本运算 向量的加法：可以理解为在坐标中两个向量的移动。 $\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} + \\begin{bmatrix} 3 \\\\ -1 \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ 1 \\end{bmatrix}$ 数字和向量相乘：可以理解为向量的缩放。 $2\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 6 \\\\ 2 \\end{bmatrix}$ 线性组合、张成空间、基 线性组合 两个数乘向量称为两个向量的线性组合$a\\vec v+ b\\vec w$。 两个不共线的向量通过不同的线性组合可以得到二维平面中的所有向量。 两个共线的向量通过线程组合只能得到一个直线的所有向量。 如果两个向量都是零向量那么它只能在原点。 张成空间 所有可以表示给定向量线性组合的向量的集合称为给定向量的张成空间（span）。 一般来说两个向量张成空间可以是直线、平面。 三个向量张成空间可以是平面、空间。 如果多个向量，并且可以移除其中一个而不减小张成空间，那么它们是线性相关的，也可以说一个向量可以表示为其他向量的线性组合$\\vec u = a \\vec v + b\\vec w$。 如果所有的向量都给张成的空间增加了新的维度，它们就成为线性无关的$\\vec u \\neq a \\vec v + b\\vec w$。 基 向量空间的一组及是张成该空间的一个线性无关向量集。 矩阵与线性变换严格意义上来说，线性变换是将向量作为输入和输出的一类函数。 变化可以多种多样，线性变化将变化限制在一个特殊类型的变换上，可以简单的理解为网格线保持平行且等距分布。 线性变化满足一下两个性质： 线性变化前后直线依旧是直线不能弯曲。 原点必须保持固定。 可以使用基向量来描述线性变化： 通过记录两个基向量$\\hat{i}$,$\\hat{j}$的变换，就可以得到其他变化后的向量。 已知向量$\\vec v = \\begin{bmatrix}-1\\\\2\\end{bmatrix}$ 变换之前的$\\hat i$和$\\hat j$： $$ \\hat{i} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\\\ \\hat{j} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\\\ \\vec{v} = -1\\hat{i} + 2 \\hat{j} = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix} $$ 变换之后的$\\hat i$和$\\hat j$： $$ \\begin{aligned} \\hat{i} = \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix} \\\\ \\hat{j} = \\begin{bmatrix} 3 \\\\ 0 \\end{bmatrix} \\\\ \\vec{v} = -1\\hat{i} + 2 \\hat{j} &= \\begin{bmatrix} 5 \\\\ 2 \\end{bmatrix} \\\\ &= -1\\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix} + 2 \\begin{bmatrix} 3 \\\\ 0 \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 3 \\\\ -2 & 0 \\end{bmatrix} \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix} \\\\ &= \\begin{bmatrix} 5 \\\\ 2 \\end{bmatrix} \\\\ \\end{aligned} $$ 我们可以将变换后的$\\hat i$和$\\hat j$写成矩阵的形式：$\\begin{bmatrix} 1 & 3 \\\\ -2 & 0 \\end{bmatrix} \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}$，通过矩阵的乘法得到变化后的向量。 如果变化后的$\\hat{i}$和$\\hat{j}$是线性相关的，变化后向量的张量就是一维空间： 矩阵乘法与线性变换复合的联系 线性变化的复合 如何描述先旋转再剪切的操作呢？ 一个通俗的方法是首先左乘旋转矩阵然后左乘剪切矩阵。 两个矩阵的乘积需要从右向左读，类似函数的复合。 这样两个矩阵的乘积就对应了一个复合的线性变换，最终得到对应变换后的$\\hat{i}$和$\\hat{j}$。 这一过程具有普适性： 矩阵乘法的顺序 如何证明矩阵乘法的结合性？ $(AB)C = A(BC)$ 根据线性变化我们可以得出，矩阵的乘法都是以CBA的顺序变换得到，所以他们本质上相同，通过变化的形式解释比代数计算更加容易理解。 三维空间的线性变化三维的空间变化和二维的类似。 同样跟踪基向量的变换，能很好的解释变换后的向量，同样两个矩阵相乘也是。 行列式 行列式的本质 行列式的本质是计算线性变化对空间的缩放比例，具体一点就是，测量一个给定区域面积增大或减小的比例。 单位面积的变换代表任意区域的面积变换比例。 行列式的值表示缩放比例。 行列式为什么有负值呢？ 三维空间的行列式类似，它的单位是一个单位1的立方体。 三位空间的线性变换，可以使用右手定则判断三维空间的定向。如果变换前后都可以通过右手定则得到，那么他的行列式就是正值，否则为负值。 行列式的计算 二阶行列式 三阶行列式 二阶行列式中a、d，表示横向和纵向的拉伸，b、c表示对角线的拉伸和压缩的情况。 逆矩阵、列空间、秩、零空间 线性方程组 从几何的角度来思考，矩阵A表示一个线性变换，我们需要找到一个$\\vec x$使得它在变换后和$\\vec v$重合。 逆矩阵 矩阵的逆运算，记为$\\vec A = \\begin{bmatrix}3&amp;1 \\\\0&amp;2\\end{bmatrix}^{-1}$，对于线程方程$A \\vec x = \\vec v $来说，找到$A^{-1}$就得到解$\\vec x = A^{-1} \\vec v$。 $A^{-1}A=\\begin{bmatrix} 1&0 \\\\ 0&1 \\end{bmatrix}$，什么都不做称为恒等变换。 线性方程组的解 对于方程组$A\\vec x = \\vec v$，线性变换A存在两种情况： $det(A) \\neq0$：这时空间的维数并没有改变，有且只有一个向量经过线性变换后和$\\vec v$重合。 $det(A) =0$：空间被压缩到更低的维度，这时不存在逆变换，因为不能将一个直线解压缩为一个平面，这样就会映射多个向量。但是即使不存在逆变换，解可能仍然存在，因为目标$\\vec v$刚好落在压缩后的空间上。 秩 秩代表变换后空间的维度。 如果线性变化后将空间压缩成一条直线，那么称这个变化的秩为1； 如果线性变化后向量落在二维平面，那么称这个变化的秩为2。 列空间 所有可能的输出向量$A\\vec v$构成的集合，称为列空间，即所有列向量张成的空间。 零空间（Null space） 所有的线性变化中，零向量一定包含在列空间中，因为线性变换原点保持不动。对于非满秩的情况来说，会有一系列的向量在变换后仍为零向量。 二维空间压缩为一条直线，一条线上的向量都会落到原点。 三维空间压缩为二维平面，一条线上的向量都会落到原点。 三维空间压缩为一条直线，整个平面上的向量都会落到原点。 当$A\\vec x = \\vec v$中的$\\vec v$是一个零向量，即$A\\vec x = \\begin{bmatrix}0 \\\\0\\end{bmatrix}$时，零空间就是它所有可能的解。 非方阵、不同维度空间之间的线性变换不同维度的变换也是存在的。 一个$3\\times2$的矩阵：$\\begin{bmatrix}2&amp;0\\-1&amp;1\\-2&amp;1 \\end{bmatrix}$它的集合意义是将一个二维空间映射到三维空间上，矩阵有两列表明输入空间有两个基向量，有三行表示每个向量在变换后用三个独立的坐标描述。 一个$2\\times 3$的矩阵：$\\begin{bmatrix}3&amp;1&amp;4\\1&amp;5&amp;9 \\end{bmatrix}$则表示将一个三维空间映射到二维空间上。 一个$1\\times 2$的矩阵：$\\begin{bmatrix}1&amp;2 \\end{bmatrix}$表示一个二维空间映射到一维空间。 点积与对偶性 点积 对于两个维度相同的向量，他们的点积计算为：$\\begin{bmatrix}1\\\\2\\end{bmatrix}\\cdot\\begin{bmatrix} 3\\\\4\\end{bmatrix}=1\\cdot3+2\\cdot4=11$。 点积的几何解释是将一个向量向一个向量投影，然后两个长度相乘，如果为负数则表示反向。 为什么点积和坐标相乘联系起来了？这和对偶性有关。 对偶性 对偶性的思想是：每当看到一个多维空间到数轴上的线性变换时，他都与空间中的唯一一个向量对应，也就是说使用线性变换和与这个向量点乘等价。这个向量也叫做线性变换的对偶向量。 当二维空间向一维空间映射时，如果在二维空间中等距分布的点在变换后还是等距分布的，那么这种变换就是线性的。 假设有一个线性变换A$\\begin{bmatrix}1&amp;-2\\end{bmatrix}$和一个向量$\\vec v=\\begin{bmatrix}4\\\\3\\end{bmatrix}$。 变换后的位置为$\\begin{bmatrix}1&amp;-2\\end{bmatrix}\\begin{bmatrix}4\\\\3\\end{bmatrix}=4\\cdot1+3\\cdot-2=-2$，这个变换是一个二维空间向一维空间的变化，所以变换后的结果为一个坐标值。 我们可以看到线性变换的计算过程和向量的点积相同$\\begin{bmatrix}1\\\\-2\\end{bmatrix}\\cdot\\begin{bmatrix}4\\\\3\\end{bmatrix}=4\\cdot1+3\\cdot-2=-2$，所以向量和一个线性变化有着微妙的联系。 假设有一个倾斜的数轴，上面有一个单位向量$\\vec v$，对于任意一个向量它在数轴上的投影都是一个数字，这表示了一个二维向量到一位空间的一种线性变换，那么如何得到这个线性变化呢？ 由之前的内容来说，我们可以观察基向量$\\vec i$和$\\vec j$的变化，从而得到对应的线性变化。 因为$\\vec i$、$\\vec j$、$\\vec u$都是单位向量，根据对称性可以得到$\\vec i$和$\\vec j$在$\\vec u$上的投影长度刚好是$\\vec u$的坐标。 这样空间中的所有向量都可以通过线性变化$\\begin{bmatrix}u_x&amp;u_y \\end{bmatrix}$得到，而这个计算过程刚好和单位向量的点积相同。 也就是为什么向量投影到直线的长度，刚好等于它与直线上单位向量的点积，对于非单位向量也是类似，只是将其扩大到对应倍数。 叉积对于两个向量所围成的面积来说，可以使用行列式计算，将两个向量看作是变换后的基向量，这样通过行列式就可以得到变换后面积缩放的比例，因为基向量的单位为1，所以就得到了对应的面积。 考虑到正向，这个面积的值存在负值，这是参照基向量$\\vec i$和$\\vec j$的相对位置来说的。 真正的叉积是通过两个三维向量$\\vec v$和$\\vec w$，生成一个新的三维向量$\\vec u$，这个向量垂直于向量$\\vec v$和$\\vec w$所在的平面，长度等于它们围成的面积。 叉积的反向可以通过右手定则判断： 叉积的计算方法： 线性代数看叉积参考二维向量的叉积计算： 三维的可以写成类似的形式，但是他并是真正的叉积，不过和真正的叉积已经很接近了。 我可以构造一个函数，它可以把一个三维空间映射到一维空间上。 右侧行列式是线性的，所以我们可以找到一个线性变换代替这个函数。 根据对偶性的思想，从多维空间到一维空间的线性变换，等于与对应向量的点积，这个特殊的向量$\\vec p$就是我们要找的向量。 从数值计算上: 向量$\\vec p$的计算结果刚好和叉积计算的结果相同。 从几何意义： 当向量$\\vec p$和向量$\\begin{bmatrix}x\\y\\z \\end{bmatrix}$点乘时，得到一个$\\begin{bmatrix}x\\y\\z \\end{bmatrix}$与$\\vec v$与$\\vec w$确定的平行六面体的有向体积，什么样的向量满足这个性质呢？ 点积的几何解释是，其他向量在$\\vec p$上的投影的长度乘以$\\vec p$的长度。 对于平行六面体的体积来说，它等于$\\vec v$和$\\vec w$所确定的面积乘以$\\begin{bmatrix}x\\y\\z \\end{bmatrix}$在垂线上的投影。 那么$\\vec p$要想满足这一要求，那么它就刚好符合，长度等于$\\vec v,\\vec w$所围成的面积，且刚好垂直这个平面。 基变换标准坐标系的基向量为$\\vec {i}: \\begin{bmatrix}1\\\\0 \\end{bmatrix}$和$\\vec {j}: \\begin{bmatrix}0\\\\1 \\end{bmatrix}$，假如詹妮弗有另一个坐标系：她的基向量为$\\vec i \\begin{bmatrix}2\\\\1 \\end{bmatrix}$和$\\vec j \\begin{bmatrix}-1\\\\1 \\end{bmatrix}$。 对于同一个点$\\begin{bmatrix}3\\\\2 \\end{bmatrix}$来说他们所表示的形式不同，在詹妮弗的坐标系中表示为$\\begin{bmatrix}\\frac{5}{3}\\\\\\frac{1}{3} \\end{bmatrix}$。 从标准坐标到詹尼佛的坐标系，我能可以得到一个线性变换$A:\\begin{bmatrix}2&amp;-1\\\\1&amp;1 \\end{bmatrix}$。 如果想知道詹妮弗的坐标系中点$\\begin{bmatrix}3\\\\2 \\end{bmatrix}$在标准坐标系的位置，可以通过$\\begin{bmatrix}2&amp;-1\\\\1&amp;1 \\end{bmatrix}\\begin{bmatrix}3\\\\2 \\end{bmatrix}$得到。 如果想知道标准坐标系中点$\\begin{bmatrix}3\\\\2 \\end{bmatrix}$在詹妮弗坐标系的位置，可以通过$\\begin{bmatrix}2&amp;-1\\\\1&amp;1 \\end{bmatrix}^{-1}\\begin{bmatrix}3\\\\2 \\end{bmatrix}$得到。 具体的例子，90°旋转。 在标准坐标系可以跟踪基向量的变化来体现： 在詹妮弗的坐标系中如何表示旋转呢？首先将向量转换为标准坐标系的表示，然后左旋，最后再转换为詹妮弗的表示。 所以我们可以得到对于詹妮弗坐标系的左旋线性变化的表示： 所以表达式$A^{-1}MA$表示一种数学上的转移作用，$M$表示一种线性变换，$A$和$A^{-1}$表示坐标系的转换。 特征向量与特征值对于一些线性变化来说，存在一些向量在变换前后留在了张成的空间里，只是拉伸或收缩了一定比例，这些向量称为特征向量，拉伸收缩的比例称为特征值。 一个三维空间的旋转，如果能找到特征值为1的特征向量，那么它就是旋转轴，因为旋转并不进行缩放，且旋转轴在线性变换中保持不变。 特征向量的求解 特征向量的概念，等号左侧表示矩阵向量的乘积，等号右侧表示向量数乘，可以将右侧重写为某个向量的乘积，$\\vec I$为单位向量。 求解等式，就是使左侧的行列式det为0，$\\lambda$就是特征值。 求解$\\lambda$对应的特征向量时，即求解满足$(A-\\lambda I)\\vec{X}=0$的所有向量$\\vec{X}$。 对应原始矩阵上所有落在$\\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$的向量被拉伸了2倍。 二维线性变换不一定存在特征向量，例如左旋90°，每个想都都发生了旋转，离开了张成空间。如果强行计算，会得到两个虚根： 剪切变换的特征向量分布在x轴： 只有一个特征值，但是特征向量不一定只在一条直线上： 特征基 一组基向量构成的集合被称为一组特征基 如果特征向量是基向量，它对应的矩阵是一个对角矩阵，矩阵的对角元是它们所属的特征值。 对角矩阵在求幂次时更方便求解，对应的幂次就是对角元的幂次。 而对于非对角矩阵的幂次求解就非常麻烦。 实际遇到对角矩阵的概率很低，但是我们可以通过基坐标变换来得到对角矩阵，前提有足够多的特征向量且可以张成整个空间，例如剪切变化就不行，应为它只有一个特征向量，无法进行坐标变换。 求解特征值： $\\begin{bmatrix}-\\lambda&amp;1\\1&amp;1-\\lambda \\end{bmatrix}\\vec{X}=0$ $$ \\begin{bmatrix}-\\lambda&1\\\\1&1-\\lambda \\end{bmatrix}\\vec{X}=0 \\\\ \\lambda=\\frac{1+\\sqrt{5}}{2},\\frac{1-\\sqrt{5}}{2} \\\\ 将\\lambda带入求导特征向量为:\\vec{v_1}=\\begin{bmatrix}2\\\\1+\\sqrt{5}\\end{bmatrix},\\vec{v_2}=\\begin{bmatrix}2\\\\1-\\sqrt{5}\\end{bmatrix}\\\\ 所以特征基为：P = \\begin{bmatrix}2&2\\\\1+\\sqrt{5}&1-\\sqrt{5}\\end{bmatrix}\\\\ P^{-1}=\\frac{1}{4\\sqrt{5}}\\begin{bmatrix}\\sqrt{5}-1&2\\\\\\sqrt{5}+1&-2\\end{bmatrix}\\\\ 构造对角矩阵：M=P^{-1}AP=\\frac{1}{2}\\begin{bmatrix}7+3\\sqrt{5}&0\\\\0&7-3\\sqrt{5}\\end{bmatrix}\\\\ A=PMP^{-1}\\\\ A^{n}=PMP^{-1}PMP^{-1}...PMP^{-1}=PM^{n}P^{-1} $$ 抽象向量空间线性的严格定义是：可加性和成比例性。 和函数的求导类似，求导具有可加性和成比例性。 对于多项式的求导，我们也可以看成是矩阵的形式，将x的不同次幂看成基函数，这和多维空间的基向量类似。 因为求导的可加性和成比例行，我们可以分别对每个基向量求导，从而得到左侧的矩阵。 数学中有很多类似向量的事物，只要处理的对象具有数乘和相加的概念，都可以运行向量的基本性质。 对于发明向量的数学家来说，他不用考虑其他所有类似的向量，他只需要给出向量数乘和加法必须遵守的规则即定理，那么所有满足这些定理的对象，就可以使用向量所拥有的性质。","link":"/Blog/LinearAlgebra/"},{"title":"cmake笔记","text":"本文的源代码：github.com/Sanzo00/cmake-examples 参考项目：github.com/ttroy50/cmake-examples 中文学习地址：cmake-examples-Chinese basichello cmake123.├── CMakeLists.txt└── main.cpp 123456789101112# CMakeLists.txt# Set the minimum version of CMake that can be used# To find the cmake version run# $ cmake --versioncmake_minimum_required(VERSION 3.5)# Set the project nameproject (hello_cmake)# Add an executableadd_executable(hello_cmake main.cpp)# add_executable(${PROJECT_NAME} main.cpp) 123456message(&quot;CMAKE_SOURCE_DIR: ${CMAKE_SOURCE_DIR}&quot;)message(&quot;CMAKE_CURRENT_SOURCE_DIR: ${CMAKE_CURRENT_SOURCE_DIR}&quot;)message(&quot;PROJECT_SOURCE_DIR: ${PROJECT_SOURCE_DIR}&quot;)message(&quot;CMAKE_BINARY_DIR: ${CMAKE_BINARY_DIR}&quot;)message(&quot;CMAKE_CURRENT_BINARY_DIR: ${CMAKE_CURRENT_BINARY_DIR}&quot;)message(&quot;PROJECT_BINARY_DIR: ${PROJECT_BINARY_DIR}&quot;) Variable Info CMAKE_SOURCE_DIR CMakeLists.txt的根目录 CMAKE_CURRENT_SOURCE_DIR 当前处理CMakeLists.txt的目录 PROJECT_SOURCE_DIR 项目根目录 CMAKE_BINARY_DIR 执行cmake的目录（build） CMAKE_CURRENT_BINARY_DIR 当前所在的build目录 PROJECT_BINARY_DIR 项目构建的目录 hello headers12345678.├── CMakeLists.txt├── include│ └── Hello.h└── src ├── Hello.cpp └── main.cpp 123456789101112131415161718# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project (hello_headers)# 创建SOURCES变量，保存所有的源文件set(SOURCES src/Hello.cpp src/main.cpp)# 创建可执行文件add_executable(hello_headers ${SOURCES})# 指定头文件target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCE_DIR}/include) static library123456789$ tree.├── CMakeLists.txt├── include│ └── static│ └── Hello.h└── src ├── Hello.cpp └── main.cpp 123456789101112131415161718192021222324252627282930# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(hello_library)##################################### Create a library####################################add_library(hello_library STATIC src/Hello.cpp)target_include_directories(hello_library PUBLIC ${PROJECT_SOURCE_DIR}/include)#################################### Create an executable#################################### Add an executable with the above sourcesadd_executable(hello_binary src/main.cpp)# link the new hello_library target with the hello_binary targettarget_link_libraries( hello_binary PRIVATE hello_library) 1234# 创建静态库文件 libhello_library.aadd_library(hello_library STATIC src/Hello.cpp) shared library123456789$ tree.├── CMakeLists.txt├── include│ └── shared│ └── Hello.h└── src ├── Hello.cpp └── main.cpp 1234567891011121314151617181920212223242526272829303132# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(hello_library)######################################## Create a library#######################################add_library(hello_library SHARED src/Hello.cpp)add_library(hello::library ALIAS hello_library)target_include_directories(hello_library PUBLIC ${PROJECT_SOURCE_DIR}/include)######################################## Create an executable#######################################add_executable(hello_binary src/main.cpp)target_link_libraries(hello_binary PRIVATE hello::library) 1234567# 创建动态库文件 libhello_library.soadd_library(hello_library SHARED src/Hello.cpp)# 对库起别名为hello:libraryadd_library(hello::library ALIAS hello_library) installing1234567891011$ tree.├── cmake-examples.conf├── CMakeLists.txt├── include│ └── installing│ └── Hello.h├── README.adoc└── src ├── Hello.cpp └── main.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(cmake_install)############################################# Create a library############################################add_library(cmake_inst SHARED src/Hello.cpp)target_include_directories(cmake_inst PUBLIC ${PROJECT_SOURCE_DIR}/include)############################################# Create an executable############################################add_executable(cmake_install_bin src/main.cpp)target_link_libraries(cmake_install_bin PRIVATE cmake_inst)############################################# Install############################################# Binariesinstall(TARGETS cmake_install_bin DESTINATION bin)# Libraryinstall(TARGETS cmake_inst LIBRARY DESTINATION lib)# Header filesinstall(DIRECTORY ${PROJECT_SOURCE_DIR}/include/ DESTINATION include)# Configinstall(FILES cmake.conf DESTINATION etc)# set make install directoryif(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT) set(CMAKE_INSTALL_PREFIX &quot;${CMAKE_BINARY_DIR}/install&quot; CACHE PATH &quot;The path to use for make install&quot; FORCE)endif()# Debug for CMAKE_INSTALL_PREFIXmessage(&quot;CMAKE_INSTALL_PREFIX: &quot; ${CMAKE_INSTALL_PREFIX}) 12345678910111213# 指定make instal的目录为./installcmake .. -D CMAKE_INSTALL_PREFIX=./install# 在未指定install目录时，可以在CMakeLists.txt中设置make install的目录if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT) set(CMAKE_INSTALL_PREFIX &quot;${CMAKE_BINARY_DIR}/install&quot; CACHE PATH &quot;The path to use for make install&quot; FORCE)endif()# 在make install也可以通过DESTDIR=/tmp/stage，安装到${DESTDIR}/${CMAKE_INSTALL_PREFIX}make install DESTDIR=/tmp/stage# Uninstallsudo xargs rm &lt; install_manifest.txt build type1234$ tree.├── CMakeLists.txt├── main.cpp 123456789101112131415161718# CMakeLists.txtcmake_minimum_required(VERSION 3.5)# Set a default build type if none was specified# Release, Debug, MinSizeRel, RelWithDebInfoif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES) message(&quot;Setting build type to 'RelWithDebInfo' as none was specified.&quot;) set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING &quot;Choose the type of build.&quot; FORCE) # Set the possible values of build type for cmake-gui set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS &quot;Debug&quot; &quot;Release&quot; &quot;MinSizeRel&quot; &quot;RelWithDebInfo&quot;)endif()project(build_type)add_executable(${PROJECT_NAME} main.cpp) Cmake提供四种构建类型： Release，-O3 -DNDEBUG Debug，-g MinSizeRel，-Os -DNDEBUG RelWithDebInfo，-O2 -g -DNDEBUG 123456789101112# 用户在cmake时指定编译类型cmake .. -DCMAKE_BUILD_TYPE=Release# 设置默认的构建类型# Release, Debug, MinSizeRel, RelWithDebInfoif(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES) message(&quot;Setting build type to 'RelWithDebInfo' as none was specified.&quot;) set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING &quot;Choose the type of build.&quot; FORCE) # Set the possible values of build type for cmake-gui set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS &quot;Debug&quot; &quot;Release&quot; &quot;MinSizeRel&quot; &quot;RelWithDebInfo&quot;)endif() compile flags1234$ tree.├── CMakeLists.txt├── main.cpp 123456789101112131415161718// main.cpp#include &lt;iostream&gt;int main(int argc, char** argv) { std::cout &lt;&lt; &quot;Hello Compile Flags!&quot; &lt;&lt; std::endl;// only print if compile flag set#ifdef EX2 std::cout &lt;&lt; &quot;Hello Compile Flag EX2!&quot; &lt;&lt; std::endl;#endif#ifdef EX3 std::cout &lt;&lt; &quot;Hello Compile Flag EX3!&quot; &lt;&lt; std::endl;#endif return 0;} 123456789101112# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(compile_flags)add_executable(${PROJECT_NAME} main.cpp)# Set a default C++ compile flagset(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -DEX2&quot; CACHE STRING &quot;Set C++ Compile Flags&quot; FORCE)target_compile_definitions(${PROJECT_NAME} PRIVATE EX3) 12345678# 为特定的可执行文件或库设置compile flagstarget_compile_definitions(${PROJECT_NAME} PRIVATE EX3)# 设置全局的compile flagsset(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -DEX2&quot; CACHE STRING &quot;Set C++ Compile Flags&quot; FORCE)# 通过cmake设置cmake .. -DCMAKE_CXX_FLAGS=&quot;-DEX3&quot; third party library12# 安装依赖sudo apt install libboost-system-dev libboost-filesystem-dev 1234$ tree.├── CMakeLists.txt├── main.cpp 12345678910111213141516171819202122// main.cpp#include &lt;iostream&gt;#include &lt;boost/shared_ptr.hpp&gt;#include &lt;boost/filesystem.hpp&gt;int main(int argc, char** argv) { std::cout &lt;&lt; &quot;Hello Third Party Include!&quot; &lt;&lt; std::endl; // use a shared ptr boost::shared_ptr&lt;int&gt; isp(new int(4)); // trivial use of boost filesystem boost::filesystem::path path = &quot;/usr/share/cmake/modules&quot;; if (path.is_relative()) { std::cout &lt;&lt; &quot;Path is relative&quot; &lt;&lt; std::endl; } else { std::cout &lt;&lt; &quot;Path is not relative&quot; &lt;&lt; std::endl; } return 0;} 123456789101112131415161718192021222324# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(third_party_library)# find a boost install with the libraries filesystem and systemfind_package(Boost 1.46.1 REQUIRED COMPONENTS filesystem system)# check if boost was foundif(Boost_FOUND) message(&quot;boost found&quot;)else() message(FATAL_ERROR &quot;Cannot find boost&quot;)endif()add_executable(${PROJECT_NAME} main.cpp)# link against the boost librariestarget_link_libraries(${PROJECT_NAME} PRIVATE Boost::filesystem) 查找库 12# find packagefind_package(Boost 1.46.1 REQUIRED COMPONENTS filesystem system) Boost为库的名称 1.46.1是最低的版本号 REQUIRED表示这是必需的库，如果找不到报错。 COMPONENTS是要查找的库列表 检查库是否存在 大多数被包含的库都会设置变量xxx_FOUND 123456# check if boost was foundif(Boost_FOUND) message(&quot;boost found&quot;)else() message(FATAL_ERROR &quot;Cannot find boost&quot;)endif() 如果库存在，一般会设置如下参数用来定位库： xxx_INCLUDE_DIRS - 头文件位置 xxx_LIBRARY - 库位置 1234567891011# Include the boost headerstarget_include_directories( third_party_include PRIVATE ${Boost_INCLUDE_DIRS})# link against the boost librariestarget_link_libraries( third_party_include PRIVATE ${Boost_SYSTEM_LIBRARY} ${Boost_FILESYSTEM_LIBRARY}) 别名 大多数modern CMake库包含别名，例如对于boost来说可以使用： Boost::boost for header only libraries Boost::system for the boost system library. Boost::filesystem for filesystem library. 1234target_link_libraries( third_party_include PRIVATE Boost::filesystem) compiling with clang12# install clangsudo apt install clang 1234$ tree.├── CMakeLists.txt├── main.cpp 1234# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(hello_cmake)add_executable(${PROJECT_NAME} main.cpp) 123456789101112131415161718192021222324252627282930#!/bin/bash#################################################### Delete old build.clang directory###################################################ROOT_DIR=`pwd`#dir=&quot;I-compiling-with-clang&quot;if [ -d &quot;$ROOT_DIR/build.clang&quot; ]; then echo &quot;deleting $ROOT_DIR/build.clang&quot; rm -rf $ROOT_DIR/build.clangfi#################################################### determine the clang binary before calling cmake###################################################clang_bin=`which clang`clang_xx_bin=`which clang++`if [ -z $clang_bin ]; then # 获取版本号 clang_ver=`dpkg --get-selections | grep clang | grep -v -m1 libclang | cut -f1 | cut -d '-' -f2` clang_bin=&quot;clang-$clang_ver&quot; clang_xx_bin=&quot;clang++-$clang_ver&quot;fiecho &quot;Will use clang [$clang_bin] and clang++ [$clang_xx_bin]&quot;mkdir -p build.clang &amp;&amp; cd build.clang &amp;&amp; \\ cmake .. -DCMAKE_C_COMPILER=$clang_bin -DCMAKE_CXX_COMPILER=$clang_xx_bin &amp;&amp; make CMake的编译器选项： CMAKE_C_COMPILER - The program used to compile c code. CMAKE_CXX_COMPILER - The program used to compile c++ code. CMAKE_LINKER - The program used to link your binary. building with ninja1234$ tree.├── CMakeLists.txt├── main.cpp CMake包含多种生成器：cmake --help 12345678910111213141516171819GeneratorsThe following generators are available on this platform (* marks default):* Unix Makefiles = Generates standard UNIX makefiles. Green Hills MULTI = Generates Green Hills MULTI files (experimental, work-in-progress). Ninja = Generates build.ninja files. Watcom WMake = Generates Watcom WMake makefiles. CodeBlocks - Ninja = Generates CodeBlocks project files. CodeBlocks - Unix Makefiles = Generates CodeBlocks project files. CodeLite - Ninja = Generates CodeLite project files. CodeLite - Unix Makefiles = Generates CodeLite project files. Sublime Text 2 - Ninja = Generates Sublime Text 2 project files. Sublime Text 2 - Unix Makefiles = Generates Sublime Text 2 project files. Kate - Ninja = Generates Kate project files. Kate - Unix Makefiles = Generates Kate project files. Eclipse CDT4 - Ninja = Generates Eclipse CDT 4.0 project files. Eclipse CDT4 - Unix Makefiles= Generates Eclipse CDT 4.0 project files. 接下来使用Ninja进行构建： 12345678# install ninja-buildsudo apt install ninja-buildmkdir ninja.build &amp;&amp; cd ninja.buildcmake .. -G Ninjaninja -v cpp standard设置c++的编译标准。 1234$ tree.├── CMakeLists.txt├── main.cpp 1234567891011// main.cpp#include &lt;iostream&gt;int main(int argc, char** argv) { auto message = &quot;Hello C++11&quot;; std::cout &lt;&lt; message &lt;&lt; std::endl; return 0;} 12345678910111213141516171819# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(hello_cpp11)# try conditional compilationinclude(CheckCXXCompilerFlag) # CHECK_CXX_COMPILER_FLAG的头文件CHECK_CXX_COMPILER_FLAG(&quot;-std=c++11&quot; COMPILER_SUPPORTS_CXX11) # 尝试使用flag进行编译，并把结果保存到变量中CHECK_CXX_COMPILER_FLAG(&quot;-std=c++0x&quot; COMPILER_SUPPORTS_CXX0X)# check results and add flagif (COMPILER_SUPPORTS_CXX11) set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++11&quot;)elseif(COMPILER_SUPPORTS_CXX0X) set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -std=c++0x&quot;)else() message(STATUS &quot;The compiler ${CMAKE_CXX_COMPILER} has no C++11 support. Please use a different C++ compiler.&quot;)endif()add_executable(${PROJECT_NAME} main.cpp) 另外还有两种设置c++ standard的方法： 1234567891011121314######################################################################## Using the CMAKE_CXX_STANDARD variable introduced in CMake v3.1.#######################################################################set(CMAKE_CXX_STANDARD 11)######################################################################## Using the target_compile_features function introduced in CMake v3.1.######################################################################## set the C++ standard to the appropriate standard for using autotarget_compile_features(hello_cpp11 PUBLIC cxx_auto_type)# print the list of known compile features for this version of CMakemessage(&quot;List of compile features: ${CMAKE_CXX_COMPILE_FEATURES}&quot;) sub projects sublibrary1 - A static library sublibrary2 - A header only library subbinary - An executable 123456789101112131415161718$ tree.├── CMakeLists.txt├── subbinary│ ├── CMakeLists.txt│ └── main.cpp├── sublibrary1│ ├── CMakeLists.txt│ ├── include│ │ └── sublib1│ │ └── sublib1.h│ └── src│ └── sublib1.cpp└── sublibrary2 ├── CMakeLists.txt └── include └── sublib2 └── sublib2.h 12345678# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(sub_projects)# add sub directoriesadd_subdirectory(subbinary)add_subdirectory(sublibrary1)add_subdirectory(sublibrary2) 1234567891011# sublibrary1/CMakeLists.txt# set project nameproject(sublibrary1)# add a library with the above sourcesadd_library(${PROJECT_NAME} src/sublib1.cpp)add_library(sub::lib1 ALIAS ${PROJECT_NAME})target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_SOURCE_DIR}/include) 1234567891011# sublibrary2/CMakeLists.txt# set the project nameproject(sublibrary2)add_library(${PROJECT_NAME} INTERFACE)add_library(sub::lib2 ALIAS ${PROJECT_NAME})target_include_directories(${PROJECT_NAME} INTERFACE ${PROJECT_SOURCE_DIR}/include) 1234567891011121314# subbinary/CMakeLists.txt# set project nameproject(subbinary)# create the executableadd_executable(${PROJECT_NAME} main.cpp)# link the static library from sublibrary1 using it's alias sub::lib1# link the header only library from sublibrary2 using it's alias sub::lib2# this will cause the include directories for that target to be added to this projecttarget_link_libraries(${PROJECT_NAME} sub::lib1 sub::lib2) code generationconfigure files CMakeLists.txt - Contains the CMake commands you wish to run main.cpp - The source file with main path.h.in - File to contain a path to the build directory ver.h.in - File to contain the version of the project 123456$ tree.├── CMakeLists.txt├── main.cpp├── path.h.in├── ver.h.in 1234567891011// main.cpp#include &lt;iostream&gt;#include &quot;ver.h&quot;#include &quot;path.h&quot;int main(int argc, char *argv[]){ std::cout &lt;&lt; &quot;Hello Version &quot; &lt;&lt; ver &lt;&lt; &quot;!&quot; &lt;&lt; std::endl; std::cout &lt;&lt; &quot;Path is &quot; &lt;&lt; path &lt;&lt; std::endl; return 0;} 通过CMake的configure_file()自动生成代码。 1234567891011121314151617181920212223# CMakeLists.txtcmake_minimum_required(VERSION 3.5)project(cf_example)# set a project versionset(cf_example_VERSION_MAJOR 0)set(cf_example_VERSION_MINOR 2)set(cf_example_VERSION_PATCH 1)set(cf_example_VERSION &quot;${cf_example_VERSION_MAJOR}.${cf_example_VERSION_MINOR}.${cf_example_VERSION_PATCH}&quot;)# call configure files on ver.h to set the version# uses the standard ${VARIABLE} syntax in the fileconfigure_file(ver.h.in ${PROJECT_SOURCE_DIR}/ver.h)# this file can only use the @VARIABLE syntax in the fileconfigure_file(path.h.in ${PROJECT_SOURCE_DIR}/path.h @ONLY)add_executable(${PROJECT_NAME} main.cpp)target_include_directories(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCE_DIR}) protobufprotobuf是google开源的对字符串进行序列化的库，将要序列化的数据定义写在原始文件.proto配置文件中，protobuf将数据序列化为二进制格式，节省内存，加快了数据的传输，但是降低了可读性。 AddressBook.proto - proto file from main protocol buffer example CMakeLists.txt - Contains the CMake commands you wish to run main.cpp - The source file from the protobuf example. 12345$ tree.├── AddressBook.proto├── CMakeLists.txt├── main.cpp 12345678910111213141516171819202122232425262728293031323334353637383940# CMakeLists.txt# set cmake minimum versioncmake_minimum_required(VERSION 3.5)# set the project nameproject(protobuf_exmaple)# find the protobuf compiler and librariesfind_package(Protobuf REQUIRED)# check if protobuf was foundif (PROTOBUF_FOUND) message(&quot;protobuf found&quot;)else() message(FATAL_ERROR &quot;Cannot find protobuf&quot;)endif()# generate the .h and .cxx filesPROTOBUF_GENERATE_CPP(PROTO_SRCS PROTO_HDRS AddressBook.proto)# print path message(&quot;PROTO_SRCS = ${PROTO_SRCS}&quot;)message(&quot;PROTO_HDRS = ${PROTO_HDRS}&quot;)# add an executableadd_executable(${PROJECT_NAME} main.cpp ${PROTO_SRCS} # ${PROTO_HDRS} )target_include_directories(${PROJECT_NAME} PUBLIC ${PROTOBUF_INCLUDE_DIRS} ${CMAKE_CURRENT_BINARY_DIR})target_link_libraries(${PROJECT_NAME} PUBLIC ${PROTOBUF_LIBRARIES})","link":"/Blog/cmake/"},{"title":"吴恩达机器学习笔记","text":"机器学习劝退指南… 吴恩达机器学习-B站视频 课后作业及答案：https://github.com/Sanzona/ML-homework ppt和笔记下载链接: 阿里云盘 监督学习监督学习是已经知道数据的label，例如预测房价问题，给出了房子的面积和价格。 回归问题是预测连续值的输出，例如预测房价。 分类问题是预测离散值输出，例如判断肿瘤是良性还是恶性。 无监督学习无监督学习是不知道数据具体的含义，比如给定一些数据但不知道它们具体的信息，对于分类问题无监督学习可以得到多个不同的聚类，从而实现预测的功能。 线性回归 线性回归是拟合一条线，将训练数据尽可能分布到线上。另外还有多变量的线性回归称为多元线性回归。 代价函数cost function，一般使用最小均方差来评估参数的好坏。 梯度下降梯度下降，首先为每个参数赋一个初值，通过代价函数的梯度，然后不断地调整参数，最终得到一个局部最优解。初值的不同可能会得到两个不同的结果，即梯度下降不一定得到全局最优解。 梯度下降在具体的执行时，每一次更新需要同时更新所有的参数。 梯度下降公式中有两个部分，学习率和偏导数。 偏导数，用来计算当前参数对应代价函数的斜率，导数为正则$\\theta$减小，导数为负则$\\theta$增大，通过这样的方式可以使整体向$\\theta=0$收敛。 $\\alpha$用来描述学习率，即每次参数更新的步长。$\\alpha$的大小不好确定，如果太小则需要很多步才能收敛，如果太大最后可能不会收敛甚至可能发散。 当$\\theta$处于局部最优解时，$\\theta$的值将不再更新，因为偏导为0。 这也说明了如果学习率$\\alpha$不改变，参数也可能收敛，假设偏导$&gt; 0$，因为偏导一直在向在减小，所以每次的步长也会慢慢减小，所以$\\alpha$不需要额外的减小。 单元梯度下降 梯度下降每次更新的都需要进行偏导计算，这个偏导对应线性回归的代价函数。 对代价函数求导的结果为： 梯度下降的过程容易出现局部最优解： 但是线性回归的代价函数，往往是一个凸函数。它总能收敛到全局最优。 梯度下降过程的动图展示： 多元梯度下降 通常问题都会涉及到多个变量，例如房屋价格预测就包括，面积、房间个数、楼层、价格等 因此代价函数就不再只包含一个变量，为了统一可以对常量引入变量$x_0=1$。 虽然参数的个数增多，但是对每个参数求偏导时和单个参数类似。 特征缩放多个变量的度量不同，数字之间相差的大小也不同，如果可以将所有的特征变量缩放到大致相同范围，这样会减少梯度算法的迭代。 特征缩放不一定非要落到[-1，1]之间，只要数据足够接近就可以。 $X_i = \\frac{X_i-\\mu}{\\sigma}$，$\\mu$表示平均值，$\\sigma$表示标准差。 缩放后的还原 经过线性回归得到的参数$\\theta’$，对应着缩放后的数据，如何得到缩放前的参数$\\theta$？ $$ \\begin{aligned} 不缩放，回归方程为y&=\\theta_0+x_1\\theta_1+x_2\\theta_2+\\cdots+x_n\\theta_n\\\\ 缩放，回归方程为y'&=\\theta_0'+x_1'\\theta_1'+x_2'\\theta_2'+\\cdots+x_n'\\theta_n'\\\\ \\because y'&=\\frac{y'-\\mu_y}{\\sigma_y}，x_i'=\\frac{x_i-\\mu_i}{\\sigma_i}\\\\ \\therefore \\frac{y-\\mu_y}{\\sigma_y}&=\\theta_0'+x_1'\\theta_1'+x_2'\\theta_2'+\\cdots+x_n'\\theta_n'\\\\ &=\\theta_0'+\\frac{x_1-\\mu_1}{\\sigma_1}\\theta_1'+\\frac{x_2-\\mu_2}{\\sigma_2}\\theta_2'+\\cdots+\\frac{x_n-\\mu_n}{\\sigma_n}\\theta_n'\\\\ \\therefore y&=[(\\theta_0' - \\sum_{i=1}^{n}\\frac{\\mu_i\\theta_i'}{\\sigma_i})\\sigma_y+\\mu_y]+x_1\\frac{\\theta_1'\\sigma_y}{\\sigma_1}+x_2\\frac{\\theta_2'\\sigma_y}{\\sigma_2}+\\cdots +x_n\\frac{\\theta_n'\\sigma_y}{\\sigma_n}\\\\ & \\therefore \\left\\{ \\begin{matrix} (\\theta_0' - \\sum_{i=1}^{n}\\frac{\\mu_i\\theta_i'}{\\sigma_i})\\sigma_y+\\mu_y &(i=0)\\\\ \\frac{\\theta_i'\\sigma_y}{\\sigma_i} &(i\\ne 0)\\\\ \\end{matrix} \\right. \\end{aligned} $$ 学习率学习率$\\alpha$的大小会影响梯度算法的执行，太大可能会导致算法不收敛，太小会增加迭代的次数。 可以画出每次迭代的$J(\\theta)$的变化，来判断当前算法执行的情况，然后选择合适的学习率。（调参开始…） Batch梯度下降：每一步梯度下降，都需要遍历整个训练集样本。 矩阵和向量一些数学计算转化为矩阵的形式，可以简化代码书写、提高效率、代码更容易理解。 矩阵乘法不满足交换律： 矩阵乘法满足结合律： 单位矩阵： 矩阵的逆： 首先是方阵 不是所有的矩阵都有逆 转置矩阵： 正则方程偏导等于0对应线性方程的最小值： 利用线性代数的方法直接求解$\\theta$。 $\\theta$的推导可以根据等式$X\\theta=y$得到，$X^TX$的目的是将矩阵转化为方阵，因为求矩阵的逆的前提是方阵。 矩阵可能存在 不可逆的情况，这时可是删除一些不必要的特征，或使用正则化。 梯度下降和正则方程的优缺点： 逻辑回归Logistic Regression 逻辑回归用于解决分类的问题，如果使用线性回归可能会造成很大的误差；假如样本的标签值为0、1，线性回归输出值是连续的存在&gt;1和小于0的情况，不符合实际。 如果对于一个均匀的数据，使用线性回归，选取0.5作为分界线，可能会得到一个比较准确的模型，但是如果数据不太均匀就会存在很大的误差。 激活函数sigmoid.py 激活函数的y值分布在[0,1]内，对于分类问题，我们可以使用激活函数的值来表示满足特征的概率。 决策界限决策边界是假设函数的一个属性，取决于函数的参数，而不是数据集。 假设以x=0，y=0.5作为判断的界限，当$\\theta^Tx &gt;=0.5$，预测$y=1$；$\\theta^Tx &lt;0.5$，预测$y=0$。 [代码示例](https://github.com/Sanzona/ML-homework/blob/main/ex2-logistic regression/ex2-regularized logistic regression.ipynb) 代码示例 代价函数对于函数$f(x)=\\frac{1}{1+e^{-x}}$，如果使用类似线性回归的代价函数$\\Sigma(h(x)-y)^2$，将得到一个非凸函数，这样就不能使用梯度下降的方法求解全局最优解。 逻辑回归一般使用对数函数作为代价函数： 首先对于分类函数来说，他的输出值范围为[0,1]，得到的对数图像如下： 当评估模型参数对y=1（恶性肿瘤）进行预测的好坏时，如果实际为恶性，预测值也为1（恶性），此时的代价为0；如果实际为恶性，预测为0（良性），此时的代价为$+\\infty$，这时代价函数就很好的评估了参数$\\theta$的表现。 同样对于y=0（良性肿瘤）的代价函数为： y的取值只有0、1，可以将上面两个函数合成一个，评估当前参数的$J(\\theta)$为： 梯度下降在确定代价函数之后的任务是，如何最小化代价函数，因为代价函数是凸的，所以可以使用梯度下降求解。 虽然求偏导之后，$\\theta$更新的形式和线性回归类似，但是他们本质不同，因为$h_\\theta(x)$完全不一样。 具体的偏导推导过程： 多元分类 对每个特征单独训练，在做预测的时候，取三个分类器结果最大的。 过拟合存在多个特征，但是数据很少，或者模型函数不合理，都会出现过拟合的现象。过拟合可能对样本数能够很好的解释，但是无法正确的预测新数据。 正则化解决过拟合的方法： 正则化处理过拟合问题： 在代价函数中加入正则项，通过lambda的来平衡拟合程度和参数的大小，$\\theta$约大越容易出现过拟合的现象。 如果lambda过大，导致$\\theta \\approx 0$，那么最终只剩下下$\\theta_0$，图像将变成一个直线。 模型评估训练、测试集将数据集分为训练集和测试集，训练集得到参数$\\theta$，然后使用测试集的数据对参数$\\theta$进行评估，即计算误差。 线性回归问题的评估： 逻辑回归问题的评估： 训练、验证、测试集首先用训练集得到一个最优的参数$\\theta$，然后用测试集进行评估误差。通过这样的方式可以在众多模型中选择一个理想的模型。 但是这样做并不能评估模型的泛化能力，通过测试集评估选择的模型，可能刚好适合测试集的数据，并不能说明它对其他数据的预测能力，这时就引入了验证集。 将数据集分为：训练集、验证集、测试集。 对于每个集合都可以计算相应的误差。 这样在选择模型的时候，可以先使用测试集得到每个模型的$\\theta$，然后使用验证集评估得到误差最小的模型，最后使用测试集评估他的泛化能力。 偏差、方差当多项式次数增大时，训练集的误差慢慢减小，因为多项式次数越高，图像拟合的就越准确。但是验证集不同，它的趋势是先减少后增大，这分别对应着欠拟合和过拟合。 那么我们可以根据误差的不同表现来区分偏差和方差。 高偏差：训练误差和验证误差都很大。 高方差：训练误差小，验证误差大。 正则化通过引入$\\lambda$来平衡多形式的权重。 当$\\lambda$太大，参数$\\theta \\approx0$，模型近似直线，即欠拟合。当$\\lambda$太小，就会出现过拟合。 学习曲线随着数据量的增加，$J_{train}(\\theta)$的误差慢慢增大，因为数据越少，模型越容易拟合；$J_{cv}(\\theta)$慢慢减少，因为数据越多，模型越精准，所以误差减小。 高偏差的模型的学习曲线： 因为参数很少，数据很多，所以随着数据的增多高偏差的模型的$J_{train}(\\theta)$和$J_{cv}(\\theta)$很接近。这时选择增加数据就不是很好的选择了，可以尝试增加数据的特征。 高方差的模型的学习曲线： 高方差的特点是训练误差和验证误差之间有很大的差距，这时可以选择增加数据，随着图像右移可以看出训练误差和验证误差会慢慢接近。 如何抉择 查准率、召回率例如对癌症的预测，相对于样本数据真实得癌症的人非常少，大概只有0.5%的概率，这样的问题称为偏斜类，一个类中的样本数比另一个类多得多。 对于偏斜类的问题，如何评估模型的精准度呢？可能一个只输出y=1的函数都比你的模型准确。 这里引入了查准率和召回率，对于稀有的样本有： 通常如果阈值设置的比较高，那么对应的查准率高、召回率低；相反如果阈值设置的低，那么查准率低、召回率高。 F1 score如何比较权衡不同的算法呢？ 这里使用的$F_1 score$，即调和平均数（倒数的平均数）来衡量。 $F_1 score$会比较照顾数值小的一方，如果PR都为0，$F_1 score=0$；如果PR都为1，$F_1 score=1$ 神经网络大多数的机器学习所涉及到的特征非常多，对于非线性分类问题，往往需要构造多项式来表示数据之间的关系，多项式的组成方式千变万化，这对计算带来一定困扰。 大脑中的神经元结构： 机器学习中的神经网络一般包括三部分，输入层，隐藏层，输出层。 数据从输入层开始，通过激活函数前向传播到第一隐藏层，经过多个隐藏层，最后到达输出层，神经网络表示复杂的逻辑关系，主要是对隐藏层的构造。 逻辑运算 如上为一个XNOR的分类问题，$xnor=(x_1 &amp; x_2) or (\\bar{x_1} &amp; \\bar{x_2})$，我们可以搭建出每种逻辑运算的神经网络，最终整合得到XNOR的神经网络模型。 AND运算 OR运算 NOT运算 XNOR运算 $xnor=(x_1 &amp; x_2) or (\\bar{x_1} &amp; \\bar{x_2})$ 多元分类通过构建神经网络，每种输出就对应一个分类器。 代价函数 K表示输出层的单元数目，L为神经网络的层数。 前向传播 反向传播 随机初始化在对神经网络进行训练时，theta的取值要随机取值，如果都赋值为0，就会使得每一层的输出值、误差相同，从而存在大量冗余。 梯度检测在实现反向传播算法时，如何确保梯度计算正确呢？ 在数学上可以使用拉格朗日中值定理来近似的表示曲线上某一点的导数，梯度检测正是使用的这种思想。 梯度检测的使用，可以对每个参数单独进行验证。 假设通过中值定理得到的梯度为approx_grad，经过反向传播得到的梯度为grad，如果满足以下等式，则说明反向传播得到的梯度精度还行。 $$ diff = \\frac{||approx\\_grad-grad||}{||approx\\_grad+grad|||} < 10e^{-9} $$ 梯度计算正确的情况下，当算法进行学习的时候要关闭梯度检测，因为它非常耗时。 支持向量机逻辑回归模型的图像是一个曲线或复杂的曲线，SVM使用简单函数来近似这个曲线。 代价函数支持向量机在逻辑回归的基础上简化了代价函数，逻辑回归使用正则项来权衡$\\theta$的大小，以此解决过拟合的问题。SVM也是类似，它是在代价函数上添加系数C，效果等价。 最大边界SVM又叫做最大边界分类问题，观察代价函数可以得到： 最小化代价函数，就是让左侧代价函数的和尽可能等于0，即对应$\\theta^Tx$，另外还有右侧的$\\theta^2$的和最小，即向量的模尽可能小。 分类问题的界限有多种可能，SVM对于如下二分类的问题，往往会得到黑色的那条分界线，这条线恰好对应着最大的边界，因此也叫做最大边界分类问题。 代价函数中的C决定了边界的划分，如果C很大对应逻辑回归的$\\lambda$很小，模型过拟合，这样就会的到紫色的分界线，通过C的取值，我们可以决定边界的划分。 证明向量的内积，等价于投影长度的乘积。 因此$\\theta^Tx$可以写为$p||\\theta||$。 对于左侧的$\\theta$，每个x向量在$\\theta$上的投影距离很小，要满足条件那么$||\\theta||$就要增大，这样最小化代价函数的值就不是最优的，可能发生过拟合，所以SVM会得到类似右侧的边界，这样$||\\theta||$尽可能小些，因为投影距离都比左侧的要大，这也是最大边界的原因。 核函数对于一个非线性决策边界问题，我们可能使用高阶的函数进行拟合，但是是否存在比当前特征刚好的表达形式呢？ 我们可以将每种特征表示为$f_i$，使用高斯核函数来做相似度分析。 随机选择三个点作为标记，通过核函数可以得到x对应的新特征。 使用高斯函数的特点：如果相似度很高，即对应的欧几里得距离$\\approx 0$对应$f_i=1$，相反如果相似度低对应$f_i\\approx 0$。 假设我们已经训练好参数$\\theta$，那么就可以通过$\\theta^Tf \\ge 0$来进行预测，即对应红色的决策边界。 可以直接将训练集中的$x^{(i)}$作为核函数中的$l^{(i)}$。 这样对于训练中的数据$x^{(i)}$，都可以得到对应的$f^{(i)}$。 SVM在使用核函数的时候，对应代价函数就可以替换为： 和SVM中的参数C一样，核函数的$\\sigma^2$决定了拟合的程度。 k均值对于没有标签的数据来说，首先根据划分聚类的个数，随机设置聚类中心的位置，然后遍历所有的数据，把每个数据分配到离它最近的坐标，对于同一个簇的数据计算它们坐标的中心位置，并设置为新的聚类中心，以此不断的迭代。 k均值的目标函数是所有点到它所属聚类中心的距离和。 随机初始化，当聚类数量很少时，如果初始化的位置不够好，会得到一个局部最优解，解决方案是多次随机初始化，从而得到一个全局最优解。 聚类数量的选择，得到聚类数量和代价的图像，根据肘部原则选取（一般不用）；或者根据k均值聚类的目的来做判断，比如做衣服尺寸的聚类分析，根据市场需求，3个聚类or5个聚类更适合市场营销等等。 主成分分析(PCA) 主成分分析(PCA)是一种数据压缩的算法，他将数据压缩到k维度，并使得所有数据投影到新维度的距离最小。 PCA不是线性回归，一个是投影距离，一个是点与直线上点的距离。 PCA执行过程，首先对数据进行均值归一化，然后计算协方差，最后得到一个k维的矩阵。 首先对数据进行均值归一化，然后确定要压缩的目标维度，即对应向量的个数，PCA的目标是使得所有数据距离新维度的距离最小。 如何确定维度K？ 如何得到压缩直线的近似坐标？ 异常检测高斯分布可以使用高斯分布来进行异常检测。 计算m个数据集在每一个维度上的$\\mu$和$\\sigma^2$，然后根据$p(x)$得到一个概率$\\epsilon$，根据概率的大小来定义是否为异常行为。 多变量高斯分布异常检测算法，往往是把$\\mu$附近的数据认为是高频率出现的，表现在图像上类似一个圆形。在一些情况下数据并不是规则分布，单变量的高斯分布不能体现拟合椭圆形状。 多变量高斯分布引入了协方差矩阵，通过修改矩阵的值来改变高斯分布的情况。 $\\Sigma$可以理解为每个特征的缩放比例，这样就可以拟合更多的数据分布。 传统的高斯分布实际上是多变量高斯分布的特殊形式，对应矩阵在非对角线上的数为0。 传统的模型需要手动构造异常特征的组合，多变量可以自动的捕捉。不过多变量的计算复杂度高一些。 推荐系统内容推荐算法例如一个电影推荐系统，一共有n个用户，m个电影，每部电影都有一定的特征，例如爱情片的比例、动作片的比例。n个用户对看过的电影进行评分，推荐系统做的给用户推荐新电影，预测用户对新电影的评分？ 可以使用线性回归的方法进行训练，得到用户对于特征的参数$\\theta$，之后就可以根据$\\theta^TX$对电影进行打分。 优化目标函数为： 协同过滤collaborative filtering，用于特征学习，自己学习得到数据的特征值。 我们无法得到每部电影中不同特征的比例，例如电影中爱情和动作的比例？除非人工审核每一部电影，但是太耗时。 这里有一个思路，首先用户根据自己的喜好对特征打分，通过计算可以大致确定已经打过分的电影它的特征值，根据已经确定的特征值，又可以计算出每个用户对这部电影的评分。 先有鸡还是先有蛋… 根据特征向量$X$可以通过线性回归得到用户的$\\theta$向量，通过用户提供的$\\theta$向量可以估计每部电影的特征数值。这就有点像鸡和蛋的问题。 我们可以随机选取$\\theta$向量计算得到特征数值，然后再通过线性回归去更新$\\theta$，这样不停的迭代直到最后的收敛。 我们也可以将两种函数合并为一个目标函数： 低秩矩阵分解可以把n个用户对m部电影的评分结果表示为$m\\times n$的矩阵。 这个矩阵可以表示为$X\\theta^T$。 通过特征值之间的偏差，我们可以找到类型相近的电影。 均值规范化之前无论是参数$\\theta$还是特征$X$，都基于每个用户都对多个电影进行的评分，每部电影也被多个用户评分。对于新用户，他可能还没有对任何一部电影进行评分，一种思路就是把所有用户对每部电影的评分的均值作为新用户的初始评分。 随机梯度下降Stochastic gradient descent 随机梯度下降算法对每个数据分开处理，对一个数据更新所有的参数。 梯度下降算法是在每次更新参数的时候，需要计算所有数据。 对比下来SGD的速度要快一些，不过收敛性可能没GD好。 如何判断SGD的收敛？ 首先定义cost函数，然后每隔1000次迭代画出cost的图像，根据均值来判断。 如果噪声太多图像上下震荡，可以选择更多的迭代次数。 如果随着迭代次数cost增加，那么选择更小的$\\alpha$。 SGD一般不能得到全局最优，他会一直在最优值附近徘徊。 学习率的大小一般保持不变，一个思路是可以动态的改变学习率$\\alpha$的大小来提高准确度，比如随着迭代次数的增加慢慢减小$\\alpha$的值。 Mini-BatchMini-Batch gradient descent 将数据分为多份，对每一份执行GD，相当于GD和SGD的综合。 b可以取[10,100]。 Map-reduceMap-reduce and data parallelism。 Map-reduce利用了线性回归求和运算的特性，将GD对整个数据的求和处理，分摊到多个服务器上执行，最后各个服务器把结果汇总到一起进行合并。 逻辑回归也可以这样搞。 OCRpipeline 滑动窗口 获取数据下载字体，然后将它们放到一个随机北京图片上。 对图像进行人工扭曲 对语音文本加入不同的背景干扰。 首先确保算法已经有很低的偏差，整体的模型ok，然后在考虑加数据，否则只是徒劳。 然后考虑加数据的人工和时间成本。 上限分析对多个模块进行分析，让其中一个模块达到100%的准确率，然后判断它能提高整个系统多少准确率。 课后作业作业地址：https://github.com/Sanzona/ML-homework","link":"/Blog/ML-AndrewNg/"},{"title":"VSCode插件: Continue","text":"让大模型帮你写代码：Ollama + Continue。 Ollama1curl -fsSL https://ollama.com/install.sh | sh 我是在服务器上安装的，为了支持远程访问，需要修改下配置文件。 123456789101112131415161718192021sudo vim /etc/systemd/system/ollama.service[Unit]Description=Ollama ServiceAfter=network-online.target[Service]ExecStart=/usr/local/bin/ollama serveUser=rootGroup=rootRestart=alwaysRestartSec=3Environment=&quot;OLLAMA_MODELS=your_model_path/ollama/models&quot;# 添加下面两行Environment=&quot;OLLAMA_HOST=0.0.0.0&quot;Environment=&quot;OLLAMA_ORIGINS=*&quot;Environment=&quot;CUDA_VISIBLE_DEVICES=0,1,2&quot;[Install]WantedBy=default.target ollama所有可用模型：https://ollama.com/library 123456# 重启服务sudo systemctl daemon-reloadsudo systemctl restart ollama# 下载模型ollama run codellama:13b 同时部署多个模型 [可选] 1234567891011# 默认端口为11434， 这里额外部署一个11435的服务OLLAMA_HOST=0.0.0.0:11435 ollama serve# 下载模型OLLAMA_HOST=127.0.0.1:11435 ollama pull codellama:13b# 测试curl -X POST http://127.0.0.1:11435/api/generate -d '{ &quot;model&quot;: &quot;codellama:13b&quot;, &quot;prompt&quot;: &quot;Write me a function that outputs the fibonacci sequence&quot;}' Continue 在vscode的插件库上安装Continue插件。 在config.json中添加模型配置文件。 如果使用本地模型，可以注释掉&quot;apiBase&quot;: &quot;http://your_server_ip:11435&quot;，如果使用的是默认的ollama服务，端口11435 改为 11434。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&quot;models&quot;: [ { &quot;title&quot;: &quot;Codellama 7b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;codellama:7b&quot;, &quot;apiBase&quot;: &quot;http://your_server_ip:11435&quot; }, { &quot;title&quot;: &quot;Codellama 13b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;codellama:13b&quot;, &quot;apiBase&quot;: &quot;http://your_server_ip:11435&quot; }, { &quot;title&quot;: &quot;Codellama 34b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;codellama:34b&quot;, &quot;apiBase&quot;: &quot;http://your_server_ip:11435&quot; }, { &quot;title&quot;: &quot;StarCoder2 3b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;starcoder2:3b&quot;, &quot;apiBase&quot;: &quot;http://node1:11435&quot; }, { &quot;title&quot;: &quot;StarCoder2 7b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;starcoder2:7b&quot;, &quot;apiBase&quot;: &quot;http://node1:11435&quot; }, { &quot;title&quot;: &quot;starcoder2:15b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;starcoder2:15b&quot;, &quot;apiBase&quot;: &quot;http://node1:11435&quot; }, { &quot;title&quot;: &quot;Llama2 7b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;llama2:7b&quot;, &quot;apiBase&quot;: &quot;http://your_server_ip:11435&quot; }, { &quot;title&quot;: &quot;Llama2 13b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;llama2:13b&quot;, &quot;apiBase&quot;: &quot;http://your_server_ip:11435&quot; }, { &quot;title&quot;: &quot;Llama2 70b&quot;, &quot;provider&quot;: &quot;ollama&quot;, &quot;model&quot;: &quot;llama2:70b&quot;, &quot;apiBase&quot;: &quot;http://your_server_ip:11435&quot; } ], 效果 Ctrl + L选中代码，弹出聊天窗口，可以直接询问LLM，例如编写单元测试，检查bug。 Ctrl + I插入代码，弹出prompt输入框，根据需求生成代码。","link":"/Blog/continue/"},{"title":"使用Docker封印EasyConnect","text":"… EasyConnect的毒瘤行为 代理所有系统流量 安装自己的 CA 根证书 开机自启进程（EasyMonitor）：root 帐号启动，理论可以监听电脑所有行为，无法关闭，否则不能使用vpn服务。 清除EasyConnect (macOS) 使用 sudo su 获取管理员权限； 删除 12rm /Library/LaunchDaemons/com.sangfor.EasyMonitor.plistrm /Library/LaunchAgents/com.sangfor.ECAgentProxy.plist 重新启动 Mac； 打开钥匙串，删除系统钥匙串-系统-证书下面的证书（关键词 sangfor）。 注意一定要 先重启Mac再删除证书 ，因为在后台的 EasyMonitor 进程会在证书被删除后自动导入。 方案1: 使用脚本管理如果想继续使用EasyConnect在本地进行VPN服务，可以使用下面两个脚本： startEasyConnect.sh 1234#! /bin/bash/Applications/EasyConnect.app/Contents/Resources/bin/EasyMonitor &gt; /dev/null 2&gt;&amp;1 &amp;/Applications/EasyConnect.app/Contents/MacOS/EasyConnect &gt; /dev/null 2&gt;&amp;1 &amp; killEasyMonitor.sh 12345#! /bin/bashpkill EasyMonitorpkill ECAgentpkill ECAgentProxy 12chmod +x startEasyConnect.shchmod +x killEasyMonitor.sh 方案2: 使用Docker管理(推荐) 开启docker服务 1234567891011121314mkdir -p ~/.config/ecdatadocker run \\ --device /dev/net/tun \\ --cap-add NET_ADMIN \\ -d \\ --restart always \\ -e PASSWORD=ecconnect \\ -e URLWIN=1 \\ -v ~/.config/ecdata:/root \\ -p 5901:5901 \\ -p 1080:1080 \\ -p 8888:8888 \\ hagb/docker-easyconnect:7.6.7 使用RealVNC连接 ip: 127.0.0.1:5901, passed: ecconnect. Clash代理配置 12345678910111213- name: 'NEU-campus#🏫' type: http port: 8888 # type: socks5 # port: 1080 server: 127.0.0.1- IP-CIDR,118.202.20.98/32,NEU-campus#🏫- IP-CIDR,210.30.200.57/32,NEU-campus#🏫- IP-CIDR,219.216.64.197/32,NEU-campus#🏫- IP-CIDR,202.118.8.24/32,NEU-campus#🏫# - DOMAIN-SUFFIX,neu.edu.cn,NEU-campus#🏫 ssh代理配置 1234567891011Host node1-jump HostName your_server_ip # 目标服务器主机名 User your_user_name ProxyCommand connect -H 127.0.0.1:8888 %h %pHost node2-jump HostName your_server_ip # 目标服务器主机名 User yuanh ProxyCommand connect -H 127.0.0.1:8888 %h %p# then use `ssh node2-jump` to connect the node2 server. Reference 解决EasyConnect的毒瘤行为 用docker封印EasyConnect并连接远程桌面和数据库 封印 Easyconnect 使用 Docker 封印 EasyConnect","link":"/Blog/easyconnect/"},{"title":"git笔记","text":"git迷路指南 Commit格式123456789feat: 新增 featurefix: 修复 bugdocs: 仅仅修改了文档，比如 README, CHANGELOG, CONTRIBUTE等等style: 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑refactor: 代码重构，没有加新功能或者修复 bugperf: 优化相关，比如提升性能、体验test: 测试用例，包括单元测试、集成测试等chore: 改变构建流程、或者增加依赖库、工具等revert: 回滚到上一个版本 常用命令Version Control（Git） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 查看hash对应的文件内容git cat-file -p &lt;hash&gt;# 以graph的格式展示log信息git log --all --graph --decorategit log --all --graph --decorate --oneline# 查看文件的修改git diff &lt;filename&gt;git diff master &lt;filename&gt;git diff &lt;branch&gt; &lt;branch&gt; &lt;filename&gt;git diff &lt;hash&gt; &lt;hash&gt; &lt;filename&gt;git diff --cached# 切换分支git checkout &lt;branch&gt;git checkout -b &lt;branch&gt; # 新建分支并切换git checkout &lt;filenam&gt; # 丢弃修改# 分支合并git merge &lt;branch&gt;# 删除分支git branch -d &lt;branch&gt;git push origin --delete &lt;branch&gt;git push origin :&lt;branch&gt;# 设置upstreamgit branch --set-upstream-to=origin/master# 同步git remote add &lt;name&gt; &lt;url&gt;git push &lt;name&gt; &lt;local branch&gt;:&lt;remote branch&gt;git pull &lt;name&gt; &lt;remote branch&gt;:&lt;local branch&gt;# 仅选择需要add的行git add -p &lt;filename&gt;# 查看修改情况git blame &lt;filename&gt; # 查看修改对应的idgit show &lt;hash&gt; # 查看commit信息# 临时保存git stashgit stash --include-untrackedgit stash listgit stash show -p stash@{0}git stash drop stash@{0}git stash pop# fork后的同步# 设置upstreamgit remote add upstream https://github.com/xxx/xxx.git# 同步原仓库的更新git fetch upstream# 合并git checkout mastergit merge upstream/master# submodule git submodule update --init --recursivegit submodule add your_repository.git# 将其他分支的commit迁移到目标分支git checkout &lt;target-branch&gt;git cherry-pick &lt;commit-hash&gt; 工作流123456789101112131415161718192021# 创建本地分支git checkout -b my-feature# 同步到remotegit push origin my-feature# 将remote main的分支同步到本地分支git checkout maingit pull origin maingit checkout my-featuregit rebase maingit push -f origin my-feature# main合并pull request (squash and merge)git checkout maingit merge --squash my-feature# 删除分支git checkout maingit branch -d my-featuregit push origin --delete my-feature git-简明指南 环境配置 配置用户信息 12git config --global user.name &quot;Sanzo00&quot;git config --global user.email &quot;arrangeman@163.com&quot; 生成ssh-key 1ssh-keygen -t rsa -C &quot;arrangeman@163.com&quot; 将生成的公钥文件~/.ssh/id_rsa.pub添加到Github上。 版本回退 修改文件后提交修改到版本库 12git add .git commit -m &quot;xxx&quot; 查看历史版本 12git log # 显示最近到最远的提交git reflog # 显示所有执行过的命令 回退到历史版本 1234567891011# 回到上一个版本git reset --hard HEAD^# 回到上上一个版本git reset --hard HEAD^^# 回到上一个版本 (同上)git reset --hard HEAD~1# 回到制定版本git reset --hard commit_id 工作区和暂存区 工作区: 存放项目的目录 暂存区 1234# 将文件的修改添加到暂存区中git add &quot;file&quot;# 把暂存区的修改提交到分支git commit 撤销修改123456# 本地修改没有git add到暂存区, 回退到上一个git add或git commitgit checkout -- &lt;file&gt;# 本地修改已经git add到暂存区, 撤销本次git add, 同时撤销本次修改git reset HEAD &lt;file&gt;git checkout -- &lt;file&gt; 删除文件 准备工作 1234567891011# 在工作区新建test文件touch test# 添加到暂存区git add test# 提交到分支git commit -m &quot;add test&quot;# 在本地删除testrm test# 工作区和版本库不一致git status 确定删除文件test 123git rm test# git add test 等价git commit -m &quot;remove test&quot; 恢复工作区文件(误删) 1git checkout -- &lt;file&gt; 只删除记录中的文件，本地不删除 1git rm --cached &lt;file&gt; 远程仓库 添加远程库 123456789# 初始化本地目录为git仓库git init# 关联一个远程库git remote add origin git@github.com:your_name/repo_name.gitgit push --set-upstream origin master# 本地同步远程仓库git pull origin master# 提交到远程仓库git push origin master 修改远程目录 1git remote set-url origin git@github.com:your_name/repo_name.git 克隆远程库 1git clone git@github.com:your_name/repo_name.git 本地仓库本地仓库可以用于本地端的同步，例如将本地文件定时同步到硬盘这样的场景。 比如本地的文件夹为files。 123456789101112131415# 将文件夹初始化为git目录。git init# 导出 files.git 目录git clone --bare files files.git# 把 files.git 放到硬盘中。scp -r files.git /media/sanzo/path/# 添加远程目录git remote add origin g/media/sanzo/path/files.gitgit push --set-upstream origin master# 同步git push 创建与合并分支 创建新分支 12345678# 创建dev分支git branch dev# 切换分支git checkout dev# 查看当前分支git branch# 查看所有分支git branch -a 合并分支 123456# 切换到主分支, 切换前要git commitgit checkout master# 合并dev到当前分支git merge dev# 删除dev分支git branch -d dev 解决冲突当master和dev同时修改文件, 在git merge时会出现冲突, 需要手动解决冲突, 重新提交. 123456789101112131415161718# 查看冲突信息git status# 打开冲突文件&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD5=======five&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev# &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt;表示不同的分支, 手动修改之后重新提交git add &lt;file&gt;git commit -m &quot;conflict fixed&quot;#删除dev分支git branch -d dev#查看分支合并图git log --graph 分支管理merge```, 在处理合并时如果可以, ```git```会使用```Fast forward```模式, 删除分支后会丢掉分支信息12345678```no-ff```强制禁止```Fast forward```, 在合并的时候多出一个```commit```记录, 保存分支信息```bash# 不使用 Fast forward模式合并分支git merge --no-ff -m &quot;merge with no-ff&quot; dev# 查看分区合并git log --graph --pretty=oneline --abbrev-commit Bug分支当dev分支的工作未完成, 你需要紧急修复buf, 这时可以把当前分支暂时储存起来. 完成其他工作之后, 可以恢复现场继续工作. 123456789101112131415161718192021222324# 储存现场git stash# 在master下新建分支并切换git chekcout mastergit checkout -b &lt;branch&gt;# 完成工作后提交git add &lt;file&gt;git commit -m &quot;&quot;# 回到之前分支git checkout &lt;branch&gt;# 查看保存的工作现场git stash list# 恢复现场 ## 1.恢复并删除 git stash pop ## 2.恢复, 删除 git stash apply stash@{0} git stash drop stash@{0} 在上面bug分支修复的错误, 在当前dev上同样也存在问题, 可以使用cherry-pick复制一个commit, 同事git会新创建一个commit 1git cherry-pick commit_id 更简单的, 可以先用git stash报工作现场储存起来, 然后在当前分支修复bug 之后恢复现场继续工作. Feature分支当需要添加新功能时, 可以创建feature分支, 测试完成之后, 再合并到当前分支. 12345# 创建feature分支git checkout -b feature#删除没有合并的分支git branch -D feature 多人协作12345678910111213141516# 查看远程仓库git remotegit remote -v# 将本地master分支推送到远程库git push origin master# 将远程库的dev分支创建到本地git checkout -b dev origin/dev# 多人向dev合并, 会出现冲突# 将远程库dev分支, 同步到本地git pull# git pull失败, 没有和远程库链接git branch --set-upstream-to =origin/dev dev# git pull之后, 手动解决冲突, 然后上传 Rebase多次本地提交或从远端pull下来之后, 本地的版本库会同时有多个commit, 通过–graph查看会觉得混乱, 可以使用rebase, 将多个commit合并成一个, 使得分支变得顺滑~. 123456# 合并commitgit rebase# 如果出现冲突, 需要解决冲突之后重新git rebasegit add .git rebase --continue .gitignore12345# 忽略特殊文件.gitignore# 查看file文件是否被ignoregit check-ignore -v &lt;file&gt; git服务器 安装git 1sudo apt install git 新建git用户 1sudo adduser git 公钥登录 将设备的id_rsa.pub文件导入到服务器的home/git/.ssh/authorized_keys中。 如果本地的用户名和服务器的用户名不一致，需要配置/home/user/.ssh/config文件 123Host server # 别名 HostName 192.168.1.101 # 服务器ip User git # 用户名 初始化 选定服务器的/srv/git/ 12345# 新建目录作为git的工作目录mkdir /srv/git# 修改目录分组(必须)sudo chown -R git:git /srv/git 禁用shell登录 编辑/etc/passwd 1git:x:1002:1002:,,,:/home/git:/bin/bash 改为： 1git:x:1002:1002:,,,:/home/git:/usr/bin/git-shell 新建仓库 1sudo git init --bare /srv/git/sample.git 也可以将本地的git项目上传到服务器： 1234567# 首先将本地的项目导出为.git目录git clone --bare project project.git# 相当于直接复制.git目录cp -Rf project/.git project.git# 上传到服务器scp -r project.git git@server:/srv/git 克隆项目 12git clone git@server:/srv/git/sample.gitgit clone git@server:/srv/git/project.git 空分支12345678910111213# 创建空分支 emptygit checkout --orphan empty# 删除当前目录文件git rm -rf .# 提交分支touch README.mdgit add README.mdgit commit -m &quot;new branch&quot;# 查看所有分支git branch -a","link":"/Blog/git/"},{"title":"Jump the Wall","text":"科学上网 V2ray服务端测试ip：ping.chinaz.com 证书申请：https://freessl.cn/ 1234567#X-ui面板安装bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh)# ufw开启端口ufw allow 40000:60000/tcpufw allow 40000:60000/udp 客户端Android，linux，macOS 安装包：https://github.com/v2fly/v2ray-core/releases v2ray客户端配置文件：https://github.com/Sanzo00/files/blob/master/other/v2ray.json linux端下载v2ray安装包之后，可以选择安装到本地或者直接运行可执行文件。 安装到本地 12345678wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh# 自动选择安装包sudo bash install-release.sh# 指定安装包sudo bash install-release.sh --local ./v2ray-linux-64.zip# 将配置文件拷贝到 /usr/local/etc/v2ray/config.json 直接运行可执行文件 1nohup ./v2ray run config.json &gt; v2ray.log 2&gt;&amp;1 &amp; Clash 开源桌面应用 Mac：ClashX Windows：ClashForWindows Android：ClashForAndroid 服务器配置 下载对应系统的可执行文件：Dreamacro/clash release V2ray to Clash节点转换工具：v2rayse.com/node-convert 1234567891011121314151617cd ~/softwaremkdir clash &amp;&amp; cd clash# 下载软件包wget https://github.com/Dreamacro/clash/releases/download/v1.13.0/clash-linux-amd64-v1.13.0.gz# 解压并添加权限gunzip clash-linux-amd64-v1.13.0.gzmv clash-linux-amd64-v1.13.0 clashchmod +x clash# 下载Country.mmdbwget https://github.com/Dreamacro/maxmind-geoip/releases/download/20230312/Country.mmdb# 设置clash配置文件vim config.yaml 创建systemd配置文件 1sudo vim /etc/systemd/system/clash.service 1234567891011[Unit]Description=Clash daemon, A rule-based proxy in Go.After=network.target[Service]Type=simpleRestart=alwaysExecStart=/home/sanzo/software/clash/clash -d /home/sanzo/software/clash/[Install]WantedBy=multi-user.target /home/sanzo/software/clash/clash is you clash executable file /home/sanzo/software/clash/ is your clash config directory 使用systemctl控制clash的运行： 12345sudo systemctl emable clashsudo systemctl status clashsudo systemctl start clashsudo systemctl restart clashsudo systemctl stop clash 网络测试 1wget google.com 设置终端代理终端代理123456vim ~/.bashrcexport ALL_PROXY=&quot;socks5://127.0.0.1:7890&quot;export all_proxy=&quot;socks5://127.0.0.1:7890&quot;export http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot; git代理 对http和https代理 1234567891011# http and httpsgit config --global http.proxy http://127.0.0.1:7890git config --global https.proxy https://127.0.0.1:7890# socks5git config --global http.proxy socks5://127.0.0.1:7890git config --global https.proxy socks5://127.0.0.1:7890# unsetgit config --global --unset http.proxygit config --global --unset https.proxy 对ssh代理： 12345678910111213sudo apt install connect-proxy# (or) https://github.com/larryhou/connect-proxyvim ~/.ssh/config# socks5Host github.comUser gitProxyCommand connect -S 127.0.0.1:7890 %h %p# http || httpsHost github.comUser gitProxyCommand connect -H 127.0.0.1:7890 %h %p","link":"/Blog/jump-the-wall/"},{"title":"Linux常用命令","text":"Linux common commands. 用户管理1234567891011121314151617181920# 创建用户sanzo，指定home目录和登陆的shelluseradd -d /home/sanzo -s /bin/bash -m sanzo# 设置登录密码passwd sanzo# 添加sudo组usermod -a -G sudo sanzo# 删除用户sudo userdel -r test# append ssh key to remote hostcat .ssh/id_ras.pub | ssh user@hostname &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot;# check groupgetent group groupname# delete group of usernamesudo deluser username groupname 进程管理后台执行1234567891011121314151617181920# 查看后台任务jobs# 前台执行任务fg %np's# 继续在后台执行挂起的任务bg %n # 挂起任务ctrl+z# 杀掉后台任务kill %n# 从当前shell移除disown -h %1# 后台执行nohup ./xx.exe &gt; log 2&gt;&amp;1 &amp; 查找/终止进程123456789101112131415161718# 查看占用端口的PIDlsof -i:portnetstat -tunpl | grep port# 查找指定名称的进程ps -ef | grep xxx# 获取指定名称进程的pidps -ef | grep free | grep -v grep | awk '{print $2}'# 查看指定进程的开始和执行的时间ps -eo pid,lstart,etime | grep pid# 终止进程ps -ef | grep free | grep -v grep | awk '{print $2}' | xargs kill# 终止所有指定名称的进程killall xxx 终止指定名称的进程：kill.sh 123456789101112131415161718192021222324# check input argsif [ $# -ne 1 ]; then echo &quot;Usage: ./$0 xxx&quot; exit 1fiecho &quot;kill all $1*&quot;ps -ef | grep $1 | grep -v grep | grep -v kill.shpids=$(ps -ef | grep $1 | grep -v grep | grep -v kill.sh | awk '{print $2}')#echo &quot;pids:&quot;#echo $pidsif test -z $pids; then echo &quot;$1 is alread killed!&quot;else for pid in $pids do echo &quot;kill $pid&quot; kill -9 $pid donefi 常用命令wc12345# 查看文件的行数wc -l data.txt# 查看./xx目录下.h文件的行数find ./xx -name &quot;*.h&quot; | xargs wc -l date 123456# 日期date# 格式化显示date +%Y-%m-%ddate +%H:%m cal 12345678# 显示本月的日历$ cal# 显示2020年的日历$ cal 2020# 显示2020年5月的日历$ cal 5 2020 ssh12# 将远端服务器10.1.1.1的8888端口映射到本地的8888端口ssh -L8888:localhost:8888 root@10.1.1.1 head/tail123456789# 前1000行head -n 1000 input.txt &gt; output.txt# 后1000行tail -n 1000 input.txt &gt; output.txt# 第6-10行 head -n 10 input.txt | tail -n 5 grep12# 查找当前目录下所有包含'void main()'的文件grep -rn &quot;void main()&quot; ./ gzip12# 解压到DIR目录gzip xxx.gz -d DIR tar12# 解压到DIR目录tar -xzvf xx.tar.gz -C DIR","link":"/Blog/linux-command/"},{"title":"LLM推理服务论文","text":"记录一些LLM推理优化相关的论文 [Parrot’ OSDI24]Parrot: Efficient Serving of LLM-based Applications with Semantic Variable. pdf code author Parrot这篇论文的主要贡献是提出了一个全新的推理workload：LLM Applications。 LLM Application是使用LLM来完成特定的任务（摘要，搜索，代码助手等），在一个应用中通常包含多个LLM请求。 以往推理优化系统是request-centric，即对用户的应用是透明的，“一视同仁”的处理用户的请求，缺少application-level的信息。 在LLM Application中，请求具有以下特点： 多个连续的LLM请求可能存在依赖关系。 即使在单个应用中，LLM请求可能具有不同的调度偏好。 LLM的请求之前存在大量的相似性。 由于缺少application-level的信息，现有的推理优化主要有两个问题： 网络通信开销。 任务调度等待开销。 Parrot设计了一个Semantic Variables的编程抽象，用来将用户的执行逻辑暴露给推理服务端。 基于这个Semantic Variables可以获取到应用内的LLM请求的调用依赖关系，进而做一些系统上的优化，包括DAG-based analysis，Performance Objective Deduction，Application-Centric Scheduling等。","link":"/Blog/llm_inference/"},{"title":"python环境配置","text":"python相关环境配置：Miniconda，PyTroch，Jupyter， venv。 MinicondaMiniconda是一个轻量级的Conda包管理器 安装包所有安装包：repo.anaconda.com/miniconda Linux: python3.8 Miniconda3 Linux 64-bit ​ python3.7 Miniconda3 Linux 32-bit 12# 以前的版本没有ssh问题wget https://repo.anaconda.com/miniconda/Miniconda3-4.7.12.1-Linux-x86_64.sh 配置初始化终端： 1~/miniconda3/bin/conda init 如果失败可以手动添加bin目录。 1echo &quot;export PATH=\\$PATH:/home/pi/miniconda3/bin&quot; &gt;&gt; .bashrc 使用 新建环境 12345# 新建名称为test的环境conda create --name test python=3.8 -y# arm只能创建python=3.4的环境conda create -n test python=3.4 -y 查看所有的环境 1conda env list 使用环境 12345678910# 激活环境conda activate testsource activate test # arm# 退出当前环境conda deactivatesource deactivate # arm# 删除环境conda remove -n test1 --all rpiarmv7l: miniconda3-latest-linux-armv7l.sh Berryconda3-2.0.0-Linux-armv7l.sh arm版本的miniconda最高只能安装python3.4，如果需要安装更高版本的python，需要第三方conda，这里使用的是 berryconda，目前最高支持到python3.6。 123conda config --add channels rpiconda create --name test python=3.6 -y venvpython自带的虚拟环境模块 12345678# 新建python -m venv /path/venv_name# 激活source /path/venv_name/bin/activate# 退出deactivate https://www.python.org/ftp/python/3.8.5/Python-3.8.5.tgz Pytorchold version lib torch: https://github.com/pytorch/pytorch/issues/40961 Pytorch，选择对应cuda版本。 12345torch.version # PyTorch versiontorch.cuda.is_available()torch.version.cuda # Corresponding CUDA versiontorch.backends.cudnn.version() # Corresponding cuDNN versiontorch.cuda.get_device_name(0) # GPU type build12345678910111213141516171819# install pytorch and dependencesgit clone --depth 1 --recurse-submodule https://github.com/pytorch/pytorch.gitconda create -y --name pytorch-build python=3.8conda activate pytorch-buildconda install -y astunparse numpy ninja pyyaml mkl mkl-include setuptools cmake cffi typing_extensions future six requests dataclasses pkg-config libuv# arm64mkdir pytorch-build-arm64cd pytorch-build-arm64cmake -DBUILD_SHARED_LIBS:BOOL=ON -DCMAKE_OSX_ARCHITECTURES=arm64 DCMAKE_OSX_DEPLOYMENT_TARGET=12.10 -DUSE_MKLDNN=OFF -DUSE_QNNPACK=OFF -DUSE_PYTORCH_QNNPACK=OFF -DBUILD_TEST=OFF -DUSE_NNPACK=OFF -DCMAKE_BUILD_TYPE:STRING=Release -DPYTHON_EXECUTABLE:PATH=`which python3` -DCMAKE_INSTALL_PREFIX:PATH=../pytorch-install-arm64 ../pytorchcmake --build . --target installcd ..# x86_64mkdir pytorch-build-x86_64cd pytorch-build-x86_64cmake -DBUILD_SHARED_LIBS:BOOL=ON -DCMAKE_OSX_ARCHITECTURES=x86_64 -DCMAKE_OSX_DEPLOYMENT_TARGET=12.10 -DUSE_MKLDNN=OFF -DUSE_QNNPACK=OFF -DUSE_PYTORCH_QNNPACK=OFF -DBUILD_TEST=OFF -DUSE_NNPACK=OFF -DCMAKE_BUILD_TYPE:STRING=Release -DPYTHON_EXECUTABLE:PATH=`which python3` -DCMAKE_INSTALL_PREFIX:PATH=../pytorch-install-x86_64 ../pytorchcmake --build . --target installcd .. test123456789101112# CMakeLists.txtcmake_minimum_required(VERSION 3.0 FATAL_ERROR)project(example-app)set(Torch_DIR /Users/sanzo/Software/pytorch-install-arm64)set(CMAKE_PREFIX_PATH &quot;/Users/sanzo/Software/pytorch-install-arm64/share/cmake/Torch&quot;)find_package(Torch REQUIRED)set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} ${TORCH_CXX_FLAGS}&quot;)add_executable(example-app example-app.cpp)target_link_libraries(example-app &quot;${TORCH_LIBRARIES}&quot;)set_property(TARGET example-app PROPERTY CXX_STANDARD 14) 1234567891011121314151617#include &lt;torch/torch.h&gt;#include &lt;iostream&gt;int main() { std::cout &lt;&lt; &quot;PyTorch version: &quot; &lt;&lt; TORCH_VERSION_MAJOR &lt;&lt; &quot;.&quot; &lt;&lt; TORCH_VERSION_MINOR &lt;&lt; &quot;.&quot; &lt;&lt; TORCH_VERSION_PATCH &lt;&lt; std::endl; torch::Tensor tensor = torch::rand({2, 3}); std::cout &lt;&lt; tensor &lt;&lt; std::endl;}/* 0.0598 0.7058 0.0322 0.2230 0.4112 0.9342[ CPUFloatType{2,3} ]*/ references old version lib torch: https://github.com/pytorch/pytorch/issues/40961 https://dev-discuss.pytorch.org/t/universal-binaries-for-libtorch-mac/229 https://github.com/pytorch/pytorch/issues/63558 jupyter notebookipykernel通过ipykernel管理jupyter notebook的内核。 1234567891011121314# 激活环境activate env_name# 安装ipykernelpip install ipykernel# 添加kernelpython -m ipykernel install --name env_name# 删除内核jupyter kernelspec remove kernelname# 查看所有内核jupyter kernelspec list 远程访问生成密钥 12345678910111213141516# 通过ipython生成密码ipythonIn [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: Out[3]: 'xxxxxxxxxxxxxxxxxxxxxx'# 生成配置文件，并添加如下配置jupyter notebook --generate-configc.NotebookApp.ip='0.0.0.0'c.NotebookApp.password = u'xxxxxxxxxxxxxxxxxxxxxx'c.NotebookApp.open_browser = Falsec.NotebookApp.port =8888 然后就可以通过https://ip:8888远程访问jupyter notebook","link":"/Blog/python-env/"},{"title":"RAG介绍","text":"RAG是什么？目前的研究现状如何？ RAG介绍 什么是LLM？ 大语言模型（Large Language Model，LLM）是基于海量数据集进行预训练的超大规模的深度学习模型。OpenAI发布的ChatGPT使人们意识到，具有足够的训练数据和巨大的参数的神经网络模型可以捕获人类语言的大部分语法和语义。得益于与LLM出色的语言理解能力，LLM被广泛的应用于各种下游任务，例如文案写作，知识问答，文本分类，代码生成，文本生成等。虽然LLM在很多领域具有出色的表现，但是它面临诸如幻觉，过时的知识，缺乏可解释性等挑战。 RAG的执行流程 检索增强生成（Retrieval Augmented Generation，RAG）包含检索和生成两部分。如图1所示，在处理用户请求之前，RAG系统首先对外部数据（文档，语音，视频等非结构化数据）进行预处理（生成向量等），并存储到知识数据库中以供后续检索使用。当接收到用户的请求时，RAG系统首先从知识数据库中检索与问题相关的知识，然后将检索得到的知识和用户的问题一起输入到LLM，生成最终的答案。通过外挂知识库的方法，RAG一定程度缓解了LLM的幻觉，时效性差，和不可解释等问题。 目前的RAG形态主要分为VectorRAG和GraphRAG两种。 VectorRAG VectorRAG使用向量来组织外部的知识。如图2所示，VectorRAG首先将文档划分为多个文本块（chunk）。每个文本块通过嵌入模型得到对应的向量表示，然后存储到向量数据库中。对于用的的请求，VectorRAG对用户的问题生成嵌入向量。然后，从向量数据库检索与问题嵌入向量相似的向量并返回对应的文本块。 VectorRAG的优点是：（1）检索速度快。（2）丰富的上下文语义信息。 VectorRAG的缺点是：（1）由于信息分散导致的检索不完整性。（2）由于语义导致的不准确性。 举个具体的例子，例如我们基于《乔布斯自传》来回答用户的问题。与用户问题相关的文本块可能有30个，而且它们分散的存储在书中的不同位置。此时，如果只取top K个片段很难得到这种分散，细粒度的完整信息。而且这种方法容易一楼相互关联的文本块，从而导致检索信息的不完整。 另外，基于嵌入的语义搜索存在不准确的问题，例如“保温杯”和“保温大棚”，这两个关键词在语义空间上存在很大的相似性，然而在真实的场景中，我们并不希望这种通用语义下的相关性出现，进而作为错误的上下文而引入”幻觉“。 GraphRAG ==重新整理== GraphRAG是一种使用知识图谱（Knowledge Graph，KG）来组织外部数据的RAG。与向量RAG相比，GraphRAG具有更加细粒度的知识形式，而且，通过在图上查询目标实体的多跳邻居，可以查询相互关联的信息，即使他们不在同一个文本块内部。 GraphRAG的执行过程可以简单概括为以下三步： 从问题中提取实体 从知识图谱中检索得到子图 根据子图构造上下文 图3是Graph和Vector联合RAG的流程图。首先对外部的文档构建索引（向量索引和KG索引），用户后续的数据检索。当用户提交一个问题的查询时，首先通过嵌入模型对用户的问题生成向量表示，然后分别从向量数据库中检索语义相关的文本块；从知识图谱数据库中检索相关的实体，然后遍历得到实体相关的查询子图。最后将向量检索得到的文本块和知识图谱检索得到的查询子图，联合问题一起输入到LLM生成问题的回答。 GraphRAG可以看作是对已有方法的额外扩展。通过将知识图谱引入到RAG中，GraphRAG可以利用现有或者新建的知识图谱，提取细粒度，领域特定且相互关联的知识。 研究现状==想个分类== OP-RAG [arixv’24]paper 这篇论文讨论了RAG在Long-context LLM下是否还是有必要存在的问题？ 结论是：Long-context LLM可能会导致对相关信息的关注减少，从而可能降低问答任务中的答案质量。因此RAG还是有必要存在的，通过使用RAG可以有效的输入文本的长度，同时可以获取更高的准确率。 在上下文限制的LLM中，使用RAG可以有效的减少输入大模型的文本长度，然后模型回答的准确率就取决于检索的性能。最近出现了很多Long-context的LLM模型，例如GPT-4o，Claudi-3.5，Llama3.1，Phi-3，Mistral-Large2具有128K的上下文长度，Gemini-1.5-pro甚至达到了1M的上下文窗口大小。因此这里有个问题：在Long-context LLM下，是否还有必要使用RAG？ 作者通过实验，对比了RAG在不同上下问长度下的性能。实验结果表明：随着上下文的增加，RAG性能先上升后下降。这是因为更多的上下文可能有更大的机会覆盖相关的块。然而，随着上下文长度进一步增加，答案质量会下降，因为更多不相关的块被用作干扰。 另外本文提出了一种保留检索文档原始顺序的方法，order-preserve RAG (OP-RAG)，通过实验发现可以有效的提高准确率。（没有提供insight和分析）。 EvaluationRGB [AAAI’24]paper code RGB是针对QA场景下的RAG benchmark工作，主要贡献如下： 构建了一个中英文的RAG benchmark。 从以下四个方面对RAG进行了评估，分析总结了LLM和RAG的局限性和缺点。 Noise Robustness，表示LLM可以从噪声文档中提取有用的信息。其中噪声文档，是语文题相关但是不包含答案相关的信息。 Negative Rejection，表示如果检索的文档不包含与答案相关的信息，LLM应该拒绝回答。 information Integration，表示LMM是否可以回答需要整合多个文档信息的复杂问题。 Counterfactual Robustness，表示当LLM通过prompt警告检索的信息可能包含事实错误的信息时，LLM可以识别文档中的事实错误。 数据集构造 QA instances generation，收集最新的新闻文章，然后使用ChatGPT对每个文章生成 (events, questions, and answers)。通过人工检查答案的正确性，并过滤掉一些无法从搜索引擎检索得到的数据。 Retrieve using search engine，对于每个问题，使用Google的API获取10个相关的网页，然后提取出相关的文档快。每个文档快包含300个token，使用dense retrieval model(m3e-base，all-mpnet-base-v2) 选择top-30的文本块。这些文本被分为positive documents and negative documents。 Testbeds construction for each ability noise robustness，根据比例采样不同数量的negative documents。 negative rejection，只从negative documents中采样外部文档。 information integration，对问题进行expanding或者rewriting，使得问题的答案包含多个文档的信息。 例如：”Who won the MVP of Super Bowl 2023?” can be rewrite as “Who won the MVPs of Super Bowl 2022 and 2023?” counterfactual robustness，利用LLM内部的知识生成问题的答案，然后检索出相关的文档，手动修改文档中的信息。 评估的metrics Accuracy ，用来评估noise robustness and information integration。生成的回答是否和标准答案一样。 Rejection rate，评估negative rejection。当只提供negative documents，LLM应该输出”I can not answer the question because of the insufficient information in documents.”。 Error detection rate，评估counterfactual robustness。当提供的文档包含错误的事实，LLM应该输出”There are factual errors in the provided documents.“。 Error correction rate，评估LLM在识别出检索文档的事实错误后，是否可以回答出正确的答案。 实验结果 RAG的性能随着噪声比例上升严重下降。存在以下问题： Long-distance information Evidence uncertainty Concept confusion. RAG很容易受到噪音信息的干扰，Negative Rejection很低。 RAG在information integration上表现不佳，存在以下问提： Merging Error，成功识别了两个问题，但是在合并答案出错。 Ignoring Error，没有正确识别两个问题，只回答了一个答案。 Misalignment Error，两个问题的答案混淆。 RAG基本没有识别事实错误的能力，因为这个RAG的基本假设冲突（模型缺乏信息，从外部检索相关信息），现有的LLM缺乏对错误信息的识别能力，严重依赖检索的信息。 参考文献 Retrieval-Augmented Generation for Large Language Models: A Survey Graph_RAG_LlamaIndex_Workshop.ipynb KG gets Fine-grained Segmentation of info. with the nature of interconnection/global-context-retained, it helps when retriving spread yet important knowledge pieces. Hallucination due to w/ relationship in literal/common sense, but should not be connected in domain Knowledge Custom Index combining KG Index and VectorStore Index Not all cases are advantageous, many other questions do not contain small-grained pieces of knowledges in chunks. In these cases, the extra Knowledge Graph retriever may not that helpful.","link":"/Blog/rag/"},{"title":"树莓派小车","text":"树莓派防吃灰玩具 代码地址：github.com/Sanzo00/pi-car 树莓派配置：sanzo.top/RaspberryPi/raspi-setup 功能展示远程控制小车 PWM变速小车在低电压情况下跑的比较慢，因此增加变速的功能。 超声波自动避障这里使用超声波测距模块（HC-SR04）实现距离检测，在此基础上实现一个简单的自动避障逻辑。 GPIO pinout12sudo apt install python3-gpiozeropinout gpio readall12wget https://project-downloads.drogon.net/wiringpi-latest.debsudo dpkg -i wiringpi-latest.deb 材料与安装 名称 数量 规格 树莓派4B 1 4G L298N电机驱动模块 1 直流减速电机 4 工作电压：3-6V，减速比：1:48 神火18650 2 3.7V 充电宝 1 5V3A HC-SR04 1 2cm-400cm L298N 接线 这里使用树莓派的GPIO的BCM编号。 IN1、IN2、IN3、IN4分别接到树莓派的5、6、13、19上。 ENA、ENB接到树莓派的20、21。 HC-SR04 测距原理 将Trig置为高电平10us，HC-SR04发送8个40khz的方波，并检测是否有信号返回，此时Echo为高电平，若有信号返回，Echo自动置为低电平，Echo高电平持续的时间既是超声波从发射到返回的时间，最后利用声波公式计算距离$dis = \\frac{time\\space \\times \\space 340m/s}{2}$。 接线 VCC接树莓派或L298N的5V电源。 GND接树莓派GND。 Echo、Trig接树莓派GPIO 14、15。 电源树莓派和L298N都单独供电，树莓派使用的是5V3A的充电宝供电，L298N使用电池盒供电。 电池盒的正极和负极，分别接到L298N的+12V、GND。 因为都是单独供电，所以将L298N的GND和树莓派的GND相互连接，这样方便同步逻辑信号。 HC-SR04使用树莓派的5V电源。","link":"/Blog/raspi-car/"},{"title":"树莓派配置","text":"树莓派新机配置 镜像Ubuntu：https://ubuntu.com/download/raspberry-pi Pi OS：https://www.raspberrypi.com/software/operating-systems balena：https://www.balena.io/etcher 更新源12345678sudo vim /etc/apt/sources.listdeb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpisudo vim /etc/apt/sources.list.d/raspi.listdeb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 修改时区Asia =&gt; Shanghai 1sudo dpkg-reconfigure tzdata vim配置http://sanzo.top/Default/vim 1234567891011121314set expandtabset softtabstop=2set autoindentset tabstop=2set shiftwidth=2set nusyntax onnoremap H ^noremap L $noremap J Gnoremap K ggnnoremap &lt; &lt;&lt;nnoremap &gt; &gt;&gt; 静态IPsudo nano /etc/dhcpcd.conf 123456789interface eth0static ip_address=192.168.31.240/24static routers=192.168.31.1static domain_name_servers=192.168.31.1interface wlan0static ip_address=192.168.31.242/24static routers=192.168.31.1static domain_name_servers=192.168.31.1 sudo reboot 安装包1sudo apt install -y lrzsz git proxychains libboost-all-dev samba samba-common aria2 cmake proxychains1234sudo vim /etc/proxychains.conf 最后一行改为对应自己的端口# socks5 127.0.0.1 9050socks5 127.0.0.1 10800 v2rayv2ray下载地址安装包 config.json格式 脚本下载： 12345678910# auto installwget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.shsudo bash install-release.sh # sudo bash install-release.sh --local v2ray-linux-64.zipsudo vim /usr/local/etc/v2ray/config.json# 启动服务sudo systemctl enable v2raysudo systemctl start v2ray 安装包下载： 12345678910111213141516171819202122232425unzip v2ray-linux-arm64-v8a.zip# sudo vim /usr/lib/systemd/system/v2ray.service[Unit]Description=V2Ray ServiceDocumentation=https://www.v2fly.org/After=network.target nss-lookup.target[Service]User=nobodyCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICEAmbientCapabilities=CAP_NET_ADMIN CAP_NET_BIND_SERVICENoNewPrivileges=trueExecStart=/home/ubuntu/software/v2ray/v2ray run -config /home/ubuntu/software/v2ray/config.jsonRestart=on-failureRestartPreventExitStatus=23[Install]WantedBy=multi-user.target# 启动服务sudo systemctl daemon-reloadsudo systemctl enable v2raysudo systemctl start v2ray 终端代理设置： 1234export ALL_PROXY=&quot;socks5://127.0.0.1:7890&quot;export all_proxy=&quot;socks5://127.0.0.1:7890&quot;export http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;http://127.0.0.1:7890&quot; zshhttps://sanzo.top/Linux/zsh/ git123456789# 设置账号信息git config --global user.email &quot;arrangeman@163.com&quot;git config --global user.name &quot;Sanzo00&quot;# 生成公钥和私钥ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# 将公钥放到github中vim .ssh/id_rsa.pub Docker1234567891011121314# installcurl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyun# docker setupsudo systemctl enable dockersudo systemctl start docker# add $USER to docker groupssudo groupadd dockersudo usermod -aG docker $USER# test dockerdocker run --rm hello-world support ipv6 https://www.rectcircle.cn/posts/docker-ipv6/#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E6%94%AF%E6%8C%81-ipv6 方法1: 123456789101112131415# test ipv6 addressdocker exec -it qbittorrent ifconfig# ipv6 supportsudo vim /etc/docker/daemon.json{ &quot;experimental&quot;: true, &quot;ip6tables&quot;: true, &quot;ipv6&quot;: true, &quot;fixed-cidr-v6&quot;: &quot;2001:db8:1::/64&quot;}# restartsudo systemctl reload docker &amp;&amp; sudo systemctl restart docker 方法2: 12345678# start ipv6 natdocker run -d --name ipv6nat --privileged --network host --restart always -v /var/run/docker.sock:/var/run/docker.sock:ro -v /lib/modules:/lib/modules:ro robbertkl/ipv6nat# create ipv6 networkdocker network create my-net-ipv6 --ipv6 --subnet=&quot;fd00:1::1/80&quot; --gateway=&quot;fd00:1::1&quot;# run docker image with --network my-net-ipv6 打印机docker安装12345# docker install# https://yeasy.gitbook.io/docker_practice/install/raspberry-pidocker pull tigerj/cups-airprintdocker run -d --restart=always --name=cups --net=host -v /var/run/dbus:/var/run/dbus --device /dev/bus -e CUPSADMIN=&quot;ubuntu&quot; -e CUPSPASSWORD=&quot;ubuntu@print&quot; tigerj/cups-airprint 手动安装 安装CUPS 12345# 安装CUPSsudo proxychains apt install cups# 修改配置文件sudo vim /etc/cups/cupsd.conf 12# 重启服务sudo service cups restart 安装打印机驱动 12345678910111213141516# 下载安装打印机驱动wget -O foo2zjs.tar.gz http://foo2zjs.rkkda.com/foo2zjs.tar.gztar -xzvf foo2zjs.tar.gzcd foo2zjs# 安装ghostscript依赖sudo apt install ghostscriptsudo apt install dc# 编译make -j10# 安装sudo make install 浏览器访问cups的配置页面http://192.168.31.240:631，添加对应的打印机。 记得要连接上打印机，而且要用root账号登录。 Windows添加打印机 https://192.168.31.240:631/printers/HP_LaserJet_M1005 mac：https://support.apple.com/kb/DL1888?viewlocale=en_US&amp;locale=en_US 挂载硬盘1234567891011121314# 查看所用分区sudo fdisk -l# 修改配置文件sudo vim /etc/fstab# 在末尾添加/dev/sda1 /home/pi/sanzo ntfs defaults 0 0# 创建对应文件夹mkdir /home/pi/sanzo# 重新挂载sudo mount -a Samba123456789101112131415161718192021222324252627282930313233343536373839404142434445# 安装sambasudo apt install samba samba-commonsudo vim /etc/samba/smb.conf# 需要账号的登录文件夹 [share] comment = share # 注意读写权限, 需要在对应位置创建文佳夹 path = /home/pi/sanzo # 允许游客访问 public = no # 可查看 browseable = yes # 允许登录的用户 valid users = root, pi # 所用用户可写 #writable = yes # 允许个别用户可写 write list = root,pi # 如果writable和write list同时存在，则以writable为准# 不需要账号登录的文件夹 [public] comment = public # 注意读写权限, 需要在对应位置创建文佳夹 path = /home/pi/sanzo/public # 允许游客访问 public = yes # 可查看 browseable = yes # 所用用户可写 writable = yes # 允许个别用户可写 # write list = test # 如果writable和write list同时存在，则以writable为准 配置用户和密码 12345678910111213141516# 创建密码文件#sudo bash -c &quot;cat /etc/passwd |mksmbpasswd &gt; /etc/samba/smbpasswd&quot;# 启动加密口令#sudo vim /etc/samba/smb.conf#encrypt passwords = yes#smb passwd file = /etc/samba/smbpasswd# 修改密码文件的权限#sudo chmod 600 /etc/samba/smbpasswd# 为用户设置samba口令sudo smbpasswd -a pi# 重启服务sudo service smbd restart 在我的电脑地址栏输入\\192.168.31.240登录即可 清除windows下的net缓冲 123456# 查看net use# 删除对应的缓冲net use \\\\192.168.31.240\\share /d 若清除缓存后依然自动登录，则需要进入控制面板→用户账户→选择当前账户→管理你的凭据→Windows凭据→删除 qBittorrenthttps://hub.docker.com/r/linuxserver/qbittorrent 1234567891011121314151617# download imagedocker pull linuxserver/qbittorrent:latest# run imagedocker run -d \\ --name=qbittorrent \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Etc/UTC \\ -e WEBUI_PORT=18000 \\ -p 18000:18000 \\ -p 46881:46881 \\ -p 46881:46881/udp \\ -v /home/sanzo/disk/data/qbittorrent-config:/config \\ -v /home/sanzo/disk/data/private/qbittorrent:/downloads \\ --restart unless-stopped \\ linuxserver/qbittorrent:latest 在使用内网穿透访问局域网的qbittorrent服务时，需要取消勾选设置=&gt;Web UI=&gt;启动Host header属性验证。 WebDAV1234567docker pull bytemark/webdavdocker run --restart always \\ -v local-dir:/var/lib/dav/data \\ -e AUTH_TYPE=Digest -e USERNAME=User -e PASSWORD=PASSWRD \\ --publish port:80 --name webdav \\ -e LOCATION=/webdav -d bytemark/webdav 中文乱码 123456789101112131415docker exec -it webdav /bin/bashvi conf/conf-enabled/dav.confDavLockDB &quot;/var/lib/dav/DavLock&quot;Alias /webdav /var/lib/dav/data/&lt;Directory &quot;/var/lib/dav/data/&quot;&gt; Dav On Options Indexes FollowSymLinks ####### add this line (start) IndexOptions Charset=utf-8 ##################### (end) AuthType Digest AuthName &quot;WebDAV&quot; AuthUserFile &quot;/user.passwd&quot; 添加用户 1htdigest /user.passwd &quot;WebDAV&quot; user frp内网穿透frps123456789101112# configuration of frpsvim /root/sanzo/frp/frps.toml[common]bind_port = 60000vhost_http_port = 60080vhost_https_port = 60443dashboard_addr = 0.0.0.0dashboard_port = 60001dashboard_user = YOUR_NAMEdashboard_pwd = YOUR_PASSWDtoken = YOUR_TOKEN 12345678# install imagedocker pull snowdreamtech/frps# run imagedocker run --restart=always --net host -d -v /root/sanzo/frp/frps.toml:/etc/frp/frps.toml^C-name frps snowdreamtech/frps# access frps vis this linkYOUR_IP:60001 frpc1234567891011121314151617181920212223242526272829# configuration of frpcvim /home/sanzo/software/frpc/frpc.toml[common]server_addr = SERVER_IPserver_port = 60000token = SERVER_TOKENhttp_proxy = http://127.0.0.1:7890https_proxy = https://127.0.0.1:7890[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = SERVER_PORT[qbt]type = tcplocal_ip = 127.0.0.1local_port = 18000remote_port = SERVER_PORT[pi-dashboard]type = tcplocal_ip = 127.0.0.1local_port = 80remote_port = SERVER_PORT 123456# install imagedocker pull snowdreamtech/frpc# run imagedocker run --restart=always --network host -d -v /home/sanzo/software/frpc/frpc.toml:/etc/frp/frpc.toml --name frpc snowdreamtech/frpc Aria2海盗湾：https://thepiratebay.org/index.html 1337X：https://1337x.to/ LIMETORRENTS：https://www.limetorrents.pro/ TORLOCK：https://www.torlock.com/ ZOOQLE：https://zooqle.com/ YTS：https://yts.mx/ RARBG：https://rarbg.to/ 使用容器 https://hub.docker.com/r/p3terx/aria2-pro 1234567mkdir aria2-pro &amp;&amp; cd aria2-pro# 下载配置文件wget git.io/aria2-pro.yml# 运行docker-compose -f aria2-pro.yml up -d 手动安装 123456789sudo apt install -y aria2 # 创建文件夹和文件mkdir .aria2touch .aria2/aria2.sessionvim .aria2/aria2.config# 测试运行 aria2c --conf-path=/home/pi/.aria2/aria2.config 设置开机自启 123456789# 重新载入服务，并设置开机启动sudo systemctl daemon-reloadsudo systemctl enable aria# 查看aria服务状态sudo systemctl status aria# 启动，停止，重启aria服务sudo systemctl（start、stop、restart） aria AriaNg http://ariang.mayswind.net/latest 仪表盘docker1https://hub.docker.com/r/ecat/docker-pi-dashboard 手动安装 安装软件包 1sudo apt-get install nginx php7.3-fpm php7.3-cli php7.3-curl php7.3-gd php7.3-cgi 开启系统服务 12sudo service nginx restartsudo service php7.3-fpm restart 浏览器访问http://树莓派ip 修改配置文件 sudo vim /etc/nginx/sites-available/default 12345location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404;} 替换为 12345678910location / { index index.html index.htm index.php default.html default.htm default.php;} location ~\\.php$ { fastcgi_pass unix:/run/php/php7.3-fpm.sock; # fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;} 重启服务sudo service nginx restart 部署项目 123sudo git clone https://github.com/nxez/pi-dashboard.git /var/www/html/pi-dashboardsudo chown -R www-data /var/www/html/pi-dashboard 浏览器访问http://树莓派ip/pi-dashboard VNC 开启VNC服务 1sudo raspi-config 选择Interface Options =&gt; VNC，开启VNC服务。 下载VNC客户端 下载地址：realvnc 修改分辨率 如果VNC不能正常访问，可以通过修改树莓派分辨率解决。 1sudo raspi-config 选择Display Options =&gt; Resolution =&gt; Mode4，接着重启机器即可。","link":"/Blog/raspi-setup/"},{"title":"ubuntu配置","text":"ubuntu常用设置. vim1234567891011121314151617sudo apt install vim# 添加配置文件vim ~/.vimrc&quot;set paste&quot;set nopasteset expandtabset softtabstop=2set autoindentset tabstop=2set shiftwidth=2set nusyntax onset mouse=a &quot;支持鼠标滑轮set mouse=v &quot;支持鼠标选中复制&quot;set viminfo='1000,&lt;500 用户1234567891011121314# 创建用户sanzo，指定home目录和登陆的shelluseradd -d /home/sanzo -s /bin/bash -m sanzo# 设置登录密码passwd sanzo# 添加sudo组usermod -a -G sudo sanzo# 删除用户sudo userdel -r test# append ssh key to remote hostcat .ssh/id_ras.pub | ssh user@hostname &quot;cat &gt;&gt; ~/.ssh/authorized_keys&quot; 代理 配置v2ray v2ray-core/releases 123456mkdir v2ray &amp;&amp; cd v2raywget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.shsudo bash install-release.sh --local ./v2ray-linux-64.zip# local user runnohup ./v2ray run config.json &gt; v2ray.log 2&gt;&amp;1 &amp; v2ray config.json配置 proxychains 123456sudo apt install proxychains# 修改配置文件sudo vim /etc/proxychains.conf # 最后一行改为对应自己的端口socks5 127.0.0.1 10800 apt代理 123sudo vim /etc/apt/apt.conf.d/proxy.confAcquire::http::Proxy &quot;socks5h://127.0.0.1:10800&quot;;Acquire::https::Proxy &quot;socks5h://127.0.0.1:10800&quot;; bash代理 12345678vim ~/.bashrc# vim ~/.zshrcexport ALL_PROXY=&quot;socks5://127.0.0.1:10800&quot;export all_proxy=&quot;socks5://127.0.0.1:10800&quot;export http_proxy=&quot;http://127.0.0.1:10801&quot;export https_proxy=&quot;https://127.0.0.1:10801&quot;# export https_proxy=&quot;http://127.0.0.1:10801&quot; # for conda http error 在setting中设置了http，apt和bash应该可以不用再设置了，以防万一可以加上。 git1234567891011sudo apt install git# 环境配置git config --global user.email &quot;arrangeman@163.com&quot;git config --global user.name &quot;Sanzo00&quot;# 生成公钥和私钥ssh-keygen -t rsa -C &quot;your_email@example.com&quot;# 将公钥放到github中cat ~/.ssh/id_rsa.pub 代理 1234567891011121314151617181920212223# http and httpsgit config --global http.proxy http://127.0.0.1:10801git config --global https.proxy https://127.0.0.1:10801# socks5git config --global http.proxy socks5://127.0.0.1:10800git config --global https.proxy socks5://127.0.0.1:10800# unsetgit config --global --unset http.proxygit config --global --unset https.proxy# sshsudo apt install connect-proxyvim ~/.ssh/config# socks5Host github.comUser gitProxyCommand connect -S 127.0.0.1:10800 %h %p# http || httpsHost github.comUser gitProxyCommand connect -H 127.0.0.1:10801 %h %p zshhttps://sanzo.top/Linux/zsh/ 12345678# 安装zshsudo apt install zsh# 安装ohmyzshsh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;# 切换shell为zshchsh -s /bin/zsh 插件 12345678910111213141516# 自动补全git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions# 高亮git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting# 修改配置文件vim ~/.zshrcplugins=( git zsh-autosuggestions zsh-syntax-highlighting)# 重置zsh环境source ~/.zshrc 鼠标 修改滑轮速度 IMWheel 12345678910sudo apt install imwheelsudo vim ~/.imwheelrc&quot;.*&quot;None, Up, Button4, 5 # 速度None, Down, Button5, 5 # 速度Control_L, Up, Control_L|Button4Control_L, Down, Control_L|Button5Shift_L, Up, Shift_L|Button4Shift_L, Down, Shift_L|Button5 开机自启 123456789101112131415161718192021sudo ~/.config/systemd/uservim ~/.config/systemd/user/imwheel.service[Unit]Description=IMWheelWants=display-manager.serviceAfter=display-manager.service[Service]Type=simpleEnvironment=XAUTHORITY=%h/.XauthorityExecStart=/usr/bin/imwheel -dExecStop=/usr/bin/pkill imwheelRemainAfterExit=yes[Install]WantedBy=graphical-session.targetsystemctl --user daemon-reloadsystemctl --user enable --now imwheel.servicejournalctl --user --unit imwheel.service 网速监控12345678sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitor -ysudo apt updatesudo apt-get install indicator-sysmonitor# 运行indicator-sysmonitorcpu: ({cpu} {cputemp}) gpu: ({nvgputemp}) mem: ({mem}) net: {net} {totalnet} 截图我在windows上用的snipaste，不过linux还没出，有两个方案可以代替： 1、系统默认的截图工具 PrtSc – 获取整个屏幕的截图并保存到 Pictures 目录。 Shift + PrtSc – 获取屏幕的某个区域截图并保存到 Pictures 目录。 Alt + PrtSc –获取当前窗口的截图并保存到 Pictures 目录。 Ctrl + PrtSc – 获取整个屏幕的截图并存放到剪贴板。 Shift + Ctrl + PrtSc – 获取屏幕的某个区域截图并存放到剪贴板。 Ctrl + Alt + PrtSc – 获取当前窗口的 截图并存放到剪贴板。 2、flameshot 12345# installapt install flameshot# startflameshot gui 显卡显卡算力 cuda对应的最低驱动版本 Ubuntu20.04安装NVIDIA显卡驱动+cuda+cudnn配置深度学习环境 驱动安装 12# 查看显卡型号lspci | grep -i nvidia 下载驱动 123456789101112131415sudo apt install -y lightdm gcc makesudo passwd root# 切换桌面，选择lightdmsudo dpkg-reconfigure gdm3# 关闭lightdm桌面systemctl stop lightdmsudo chmod a+x NVIDIA-Linux-x86_64-450.80.02.runsudo ./NVIDIA-Linux-x86_64-450.80.02.run -no-x-check -no-nouveau-check -no-opengl-files --no-kernel-module# -no-x-check:安装时关闭X服务# -no-nouveau-check: 安装时禁用nouveau# -no-opengl-files:只安装驱动文件，不安装OpenGL文件# 后面出来的提示，选择默认选项 12# 测试是否成功nvidia-smi 如果出现/dev/xxx: clean的问题，进不了桌面，可能是因为驱动不匹配的问题。可以删除/etc/X11/xorg.conf。 如果出现An NVIDIA kernel module 'nvidia-drm' appears to already be loaded in your kernel. This may be because it is in use (for example, by an X server, a CUDA program, or the NVIDIA Persistence Daemon), but this may also happen if your kernel was configured without support for module unloading. 12345678# https://unix.stackexchange.com/questions/440840/how-to-unload-kernel-module-nvidia-drmsudo systemctl isolate multi-user.targetmodprobe -r nvidia-drm# reinstall you nvidia driver# thensudo systemctl start graphical.target 安装cuda 下载cuda，这里我选择的是cuda 11.2。 12wget https://developer.download.nvidia.com/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.27.04_linux.runsudo sh cuda_11.2.0_460.27.04_linux.run 回车取消勾选Driver，因为前面已经装过驱动，然后install，也可以在Options中自定义安装位置。 在.bashrc文件中配置环境变量 12export PATH=/usr/local/cuda-11.2/bin:${PATH}export LD_LIBRARY_PATH=/usr/local/cuda-11.2/lib64:${LD_LIBRARY_PATH} 1234source ～/.bashrc# 测试cudanvcc -V 安装cudnn 下载cudnn 1234# 将文件复制到cuda对应的文件夹下sudo cp cuda/include/cudnn.h /usr/local/cuda/include/sudo cp cuda/include/cudnn_version.h /usr/local/cuda/include/ # for cudnn v8+sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/ 测试 在~/NVIDIA_CUDA-11.2_Samples下编译代码，然后运行cuda提供的例子。 踩坑 apt 更新软件包之后，导致显卡驱动失效，这是因为内核版本发生了变化，将内核回退到上一个版本即可。 https://www.jianshu.com/p/5ac8aa703075 显示器适用于多个显示器。 我这里有两块屏幕HDMI-1，HDMI-1-0。 1234567891011121314151617# 查看当前显示器信息xrandr# 设置HDMI-1为主屏幕xrandr --output HDMI-1 --primary# 只显示一个屏幕，关闭HDMI-1-0屏幕xrandr --output HDMI-1 --auto --output HDMI-1-0 --off# 复制屏幕xrandr --output HDMI-1-0 --same-as HDMI-1 --auto# 设置HDMI-1-0为左扩展屏xrandr --output HDMI-1-0 --left-of HDMI-1 --auto# 设置HDMI-1-0右扩展屏xrandr --output HDMI-1-0 --right-of HDMI-1 --auto 开机自启 还没找到合适的开机自启命令，不过可以在系统设置中调。 VSCodevscode server端网络不好，“Downloading VS Code Server” 进入~/.vscode-server/bin/查看vscode server的commit id，然后手动下载上传到服务器。 下载链接：https://update.code.visualstudio.com/commit:${commit_id}/server-linux-x64/stable 解压之后重命名为commit id，然后放到~/.vscode-server/bin/ 其他typora python环境","link":"/Blog/ubuntu-setup/"},{"title":"yabai: macOS的窗口管理","text":"自动分屏 cite: How To Setup And Use The Yabai Tiling Window Manager On Mac setup1234567891011121314151617# install yabaibrew install koekeishiya/formulae/yabaiyabai --start-serviceyabai --restart-service# install skhdbrew install koekeishiya/formulae/skhdskhd --start-serviceskhd --restart-servicemkdir ~/.config/yabaicd ~/.config/yabaiwget https://raw.githubusercontent.com/Sanzo00/config/main/yabai/yabaircmkdir ~/.config/skhdcd ~/.configwget https://raw.githubusercontent.com/Sanzo00/config/main/skhd/skhdrc command Function Shortcuts Focus within space Alt + (H, J, K, L) Focus between display Alt + (W, E) Toggle window float Shift + Alt + F Maximize window Alt + M Balance layout Alt + B Swap window Shift + Alt + (H, J, K, L)","link":"/Blog/yabai/"},{"title":"zsh安装与配置","text":"zsh终端配置。 下载安装ohmyzsh 12345678# 安装zshsudo apt install zsh# 安装ohmyzshsh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;# 切换shell为zshchsh -s /bin/zsh 离线安装： https://www.jianshu.com/p/c65f145772c2 https://github.com/ohmyzsh/ohmyzsh/wiki/Installing-ZSH 12345# install zshhttps://sourceforge.net/projects/zsh/files/latest/downloadxz -d zsh.tar.xztar -xf zsh.tar 按键映射123456789101112131415161718192021# 编辑.zshrc文件，添加如下配置vim .zshrc#Rebind HOME and END to do the decent thing:bindkey '\\e[1~' beginning-of-linebindkey '\\e[4~' end-of-linecase $TERM in (xterm*)bindkey '\\eOH' beginning-of-linebindkey '\\eOF' end-of-lineesac#To discover what keycode is being sent, hit ^v#and then the key you want to test.#And DEL too, as well as PGDN and insert:bindkey '\\e[3~' delete-charbindkey '\\e[6~' end-of-historybindkey '\\e[2~' redisplay#Now bind pgup to paste the last word of the last command,bindkey '\\e[5~' insert-last-word 插件12345678910111213141516# 自动补全git clone https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions# 高亮git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting# 修改配置文件vim ~/.zshrcplugins=( git zsh-autosuggestions zsh-syntax-highlighting)# 重置zsh环境source ~/.zshrc 代理1234567891011# 打开配置文件vim ~/.zshrc# 在最后一行添加export ALL_PROXY=&quot;socks5://127.0.0.1:7890&quot;export all_proxy=&quot;socks5://127.0.0.1:7890&quot;export http_proxy=&quot;http://127.0.0.1:7890&quot;export https_proxy=&quot;https://127.0.0.1:7890&quot;#重新加载配置文件source ~/.zshrc","link":"/Blog/zsh/"}],"tags":[{"name":"linear algebra","slug":"linear-algebra","link":"/tags/linear-algebra/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"cmake","slug":"cmake","link":"/tags/cmake/"},{"name":"ML","slug":"ML","link":"/tags/ML/"},{"name":"continue","slug":"continue","link":"/tags/continue/"},{"name":"ollama","slug":"ollama","link":"/tags/ollama/"},{"name":"vpn","slug":"vpn","link":"/tags/vpn/"},{"name":"EasyConnect","slug":"EasyConnect","link":"/tags/EasyConnect/"},{"name":"school","slug":"school","link":"/tags/school/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"v2ray","slug":"v2ray","link":"/tags/v2ray/"},{"name":"command","slug":"command","link":"/tags/command/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"LLM, Inference","slug":"LLM-Inference","link":"/tags/LLM-Inference/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"miniconda","slug":"miniconda","link":"/tags/miniconda/"},{"name":"venv","slug":"venv","link":"/tags/venv/"},{"name":"pytorch","slug":"pytorch","link":"/tags/pytorch/"},{"name":"setup","slug":"setup","link":"/tags/setup/"},{"name":"RAG","slug":"RAG","link":"/tags/RAG/"},{"name":"pi","slug":"pi","link":"/tags/pi/"},{"name":"RaspberryPi","slug":"RaspberryPi","link":"/tags/RaspberryPi/"},{"name":"car","slug":"car","link":"/tags/car/"},{"name":"samba","slug":"samba","link":"/tags/samba/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"zsh","slug":"zsh","link":"/tags/zsh/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"}],"pages":[{"title":"About Me","text":"","link":"/about/index.html"},{"title":"线性代数","text":"基础知识行列式 二阶行列式 $ \\begin{vmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\\\ \\end{vmatrix} = a_{11}a_{22} - a_{12}a_{21} $ 三阶行列式 $ \\begin{vmatrix} a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\end{vmatrix} = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} -a_{13}a_{22}a_{31} - a_{23}a_{32}a_{11} - a_{33}a_{12}a_{21}$ 对于更高阶的行列式，一般将行列式转为三角形，这样只用计算对角线的乘积即可。 余子式$n$阶行列式，把第$a_{ij}$所在的行列删除，留下的$n-1$阶行列式称为余子式，记为$M_{ij}$。 代数余子式代数余子式的$A_{ij} = -1^{i+j}M_{ij}$。 伴随矩阵代数余子式的转置称为伴随矩阵，只有方阵才有伴随矩阵，记为$A^*$。 伴随矩阵的性质： $AA^* = A^*A = |A|E$ $A^{-1} = \\frac{1}{|A|}A^*（存在A^{-1}）$ $(A^*)^{-1}=(A^{-1})^*=\\frac{1}{|A|}A$ $|A^*|=|A|^{n-1}$ $(kA)^*=k^{n-1}A^*$ 矩阵的逆$A^{-1} = \\frac{1}{|A|}A^*（存在A^{-1}）$ $A^{-1} = \\frac{1}{|A|}A^{*}=\\frac{1}{ad-bc}\\begin{bmatrix}d &amp;-b\\ -c &amp; a\\end{bmatrix}$ 例： $\\begin{bmatrix}1&-1\\\\1&1 \\end{bmatrix}^{-1} = \\frac{1}{2}\\begin{bmatrix}1&1\\\\-1&1 \\end{bmatrix}$ 线性代数的本质b站视频链接 什么是向量向量对于不同的学科有不一样的定义。 物理中的向量有长度和方向决定，长度和方向不变可以随意移动，它们表示的是同一个向量。 计算机中的向量更多的是对数据的抽象，可以根据面积和价格定义一个房子$\\begin{bmatrix}100m^2\\\\700000￥\\end{bmatrix}$。 数学中的向量可以是任意东西，只要保证两个向量的相加$\\vec v + \\vec w$以及数字和向量相乘$2\\vec v$是有意义的即可。 线性代数中的向量可以理解为一个空间中的箭头，这个箭头起点落在原点。如果空间中有许多的向量，可以点表示一个向量，即向量头的坐标。 向量的基本运算 向量的加法：可以理解为在坐标中两个向量的移动。 $\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} + \\begin{bmatrix} 3 \\\\ -1 \\end{bmatrix} = \\begin{bmatrix} 4 \\\\ 1 \\end{bmatrix}$ 数字和向量相乘：可以理解为向量的缩放。 $2\\begin{bmatrix} 3 \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 6 \\\\ 2 \\end{bmatrix}$ 线性组合、张成空间、基 线性组合 两个数乘向量称为两个向量的线性组合$a\\vec v+ b\\vec w$。 两个不共线的向量通过不同的线性组合可以得到二维平面中的所有向量。 两个共线的向量通过线程组合只能得到一个直线的所有向量。 如果两个向量都是零向量那么它只能在原点。 张成空间 所有可以表示给定向量线性组合的向量的集合称为给定向量的张成空间（span）。 一般来说两个向量张成空间可以是直线、平面。 三个向量张成空间可以是平面、空间。 如果多个向量，并且可以移除其中一个而不减小张成空间，那么它们是线性相关的，也可以说一个向量可以表示为其他向量的线性组合$\\vec u = a \\vec v + b\\vec w$。 如果所有的向量都给张成的空间增加了新的维度，它们就成为线性无关的$\\vec u \\neq a \\vec v + b\\vec w$。 基 向量空间的一组及是张成该空间的一个线性无关向量集。 矩阵与线性变换严格意义上来说，线性变换是将向量作为输入和输出的一类函数。 变化可以多种多样，线性变化将变化限制在一个特殊类型的变换上，可以简单的理解为网格线保持平行且等距分布。 线性变化满足一下两个性质： 线性变化前后直线依旧是直线不能弯曲。 原点必须保持固定。 可以使用基向量来描述线性变化： 通过记录两个基向量$\\hat{i}$,$\\hat{j}$的变换，就可以得到其他变化后的向量。 已知向量$\\vec v = \\begin{bmatrix}-1\\\\2\\end{bmatrix}$ 变换之前的$\\hat i$和$\\hat j$： $$ \\hat{i} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\\\ \\hat{j} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\\\ \\vec{v} = -1\\hat{i} + 2 \\hat{j} = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix} $$ 变换之后的$\\hat i$和$\\hat j$： $$ \\begin{aligned} \\hat{i} = \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix} \\\\ \\hat{j} = \\begin{bmatrix} 3 \\\\ 0 \\end{bmatrix} \\\\ \\vec{v} = -1\\hat{i} + 2 \\hat{j} &= \\begin{bmatrix} 5 \\\\ 2 \\end{bmatrix} \\\\ &= -1\\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix} + 2 \\begin{bmatrix} 3 \\\\ 0 \\end{bmatrix} \\\\ &= \\begin{bmatrix} 1 & 3 \\\\ -2 & 0 \\end{bmatrix} \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix} \\\\ &= \\begin{bmatrix} 5 \\\\ 2 \\end{bmatrix} \\\\ \\end{aligned} $$ 我们可以将变换后的$\\hat i$和$\\hat j$写成矩阵的形式：$\\begin{bmatrix} 1 & 3 \\\\ -2 & 0 \\end{bmatrix} \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}$，通过矩阵的乘法得到变化后的向量。 如果变化后的$\\hat{i}$和$\\hat{j}$是线性相关的，变化后向量的张量就是一维空间： 矩阵乘法与线性变换复合的联系 线性变化的复合 如何描述先旋转再剪切的操作呢？ 一个通俗的方法是首先左乘旋转矩阵然后左乘剪切矩阵。 两个矩阵的乘积需要从右向左读，类似函数的复合。 这样两个矩阵的乘积就对应了一个复合的线性变换，最终得到对应变换后的$\\hat{i}$和$\\hat{j}$。 这一过程具有普适性： 矩阵乘法的顺序 如何证明矩阵乘法的结合性？ $(AB)C = A(BC)$ 根据线性变化我们可以得出，矩阵的乘法都是以CBA的顺序变换得到，所以他们本质上相同，通过变化的形式解释比代数计算更加容易理解。 三维空间的线性变化三维的空间变化和二维的类似。 同样跟踪基向量的变换，能很好的解释变换后的向量，同样两个矩阵相乘也是。 行列式 行列式的本质 行列式的本质是计算线性变化对空间的缩放比例，具体一点就是，测量一个给定区域面积增大或减小的比例。 单位面积的变换代表任意区域的面积变换比例。 行列式的值表示缩放比例。 行列式为什么有负值呢？ 三维空间的行列式类似，它的单位是一个单位1的立方体。 三位空间的线性变换，可以使用右手定则判断三维空间的定向。如果变换前后都可以通过右手定则得到，那么他的行列式就是正值，否则为负值。 行列式的计算 二阶行列式 三阶行列式 二阶行列式中a、d，表示横向和纵向的拉伸，b、c表示对角线的拉伸和压缩的情况。 逆矩阵、列空间、秩、零空间 线性方程组 从几何的角度来思考，矩阵A表示一个线性变换，我们需要找到一个$\\vec x$使得它在变换后和$\\vec v$重合。 逆矩阵 矩阵的逆运算，记为$\\vec A = \\begin{bmatrix}3&amp;1 \\\\0&amp;2\\end{bmatrix}^{-1}$，对于线程方程$A \\vec x = \\vec v $来说，找到$A^{-1}$就得到解$\\vec x = A^{-1} \\vec v$。 $A^{-1}A=\\begin{bmatrix} 1&0 \\\\ 0&1 \\end{bmatrix}$，什么都不做称为恒等变换。 线性方程组的解 对于方程组$A\\vec x = \\vec v$，线性变换A存在两种情况： $det(A) \\neq0$：这时空间的维数并没有改变，有且只有一个向量经过线性变换后和$\\vec v$重合。 $det(A) =0$：空间被压缩到更低的维度，这时不存在逆变换，因为不能将一个直线解压缩为一个平面，这样就会映射多个向量。但是即使不存在逆变换，解可能仍然存在，因为目标$\\vec v$刚好落在压缩后的空间上。 秩 秩代表变换后空间的维度。 如果线性变化后将空间压缩成一条直线，那么称这个变化的秩为1； 如果线性变化后向量落在二维平面，那么称这个变化的秩为2。 列空间 所有可能的输出向量$A\\vec v$构成的集合，称为列空间，即所有列向量张成的空间。 零空间（Null space） 所有的线性变化中，零向量一定包含在列空间中，因为线性变换原点保持不动。对于非满秩的情况来说，会有一系列的向量在变换后仍为零向量。 二维空间压缩为一条直线，一条线上的向量都会落到原点。 三维空间压缩为二维平面，一条线上的向量都会落到原点。 三维空间压缩为一条直线，整个平面上的向量都会落到原点。 当$A\\vec x = \\vec v$中的$\\vec v$是一个零向量，即$A\\vec x = \\begin{bmatrix}0 \\\\0\\end{bmatrix}$时，零空间就是它所有可能的解。 非方阵、不同维度空间之间的线性变换不同维度的变换也是存在的。 一个$3\\times2$的矩阵：$\\begin{bmatrix}2&amp;0\\-1&amp;1\\-2&amp;1 \\end{bmatrix}$它的集合意义是将一个二维空间映射到三维空间上，矩阵有两列表明输入空间有两个基向量，有三行表示每个向量在变换后用三个独立的坐标描述。 一个$2\\times 3$的矩阵：$\\begin{bmatrix}3&amp;1&amp;4\\1&amp;5&amp;9 \\end{bmatrix}$则表示将一个三维空间映射到二维空间上。 一个$1\\times 2$的矩阵：$\\begin{bmatrix}1&amp;2 \\end{bmatrix}$表示一个二维空间映射到一维空间。 点积与对偶性 点积 对于两个维度相同的向量，他们的点积计算为：$\\begin{bmatrix}1\\\\2\\end{bmatrix}\\cdot\\begin{bmatrix} 3\\\\4\\end{bmatrix}=1\\cdot3+2\\cdot4=11$。 点积的几何解释是将一个向量向一个向量投影，然后两个长度相乘，如果为负数则表示反向。 为什么点积和坐标相乘联系起来了？这和对偶性有关。 对偶性 对偶性的思想是：每当看到一个多维空间到数轴上的线性变换时，他都与空间中的唯一一个向量对应，也就是说使用线性变换和与这个向量点乘等价。这个向量也叫做线性变换的对偶向量。 当二维空间向一维空间映射时，如果在二维空间中等距分布的点在变换后还是等距分布的，那么这种变换就是线性的。 假设有一个线性变换A$\\begin{bmatrix}1&amp;-2\\end{bmatrix}$和一个向量$\\vec v=\\begin{bmatrix}4\\\\3\\end{bmatrix}$。 变换后的位置为$\\begin{bmatrix}1&amp;-2\\end{bmatrix}\\begin{bmatrix}4\\\\3\\end{bmatrix}=4\\cdot1+3\\cdot-2=-2$，这个变换是一个二维空间向一维空间的变化，所以变换后的结果为一个坐标值。 我们可以看到线性变换的计算过程和向量的点积相同$\\begin{bmatrix}1\\\\-2\\end{bmatrix}\\cdot\\begin{bmatrix}4\\\\3\\end{bmatrix}=4\\cdot1+3\\cdot-2=-2$，所以向量和一个线性变化有着微妙的联系。 假设有一个倾斜的数轴，上面有一个单位向量$\\vec v$，对于任意一个向量它在数轴上的投影都是一个数字，这表示了一个二维向量到一位空间的一种线性变换，那么如何得到这个线性变化呢？ 由之前的内容来说，我们可以观察基向量$\\vec i$和$\\vec j$的变化，从而得到对应的线性变化。 因为$\\vec i$、$\\vec j$、$\\vec u$都是单位向量，根据对称性可以得到$\\vec i$和$\\vec j$在$\\vec u$上的投影长度刚好是$\\vec u$的坐标。 这样空间中的所有向量都可以通过线性变化$\\begin{bmatrix}u_x&amp;u_y \\end{bmatrix}$得到，而这个计算过程刚好和单位向量的点积相同。 也就是为什么向量投影到直线的长度，刚好等于它与直线上单位向量的点积，对于非单位向量也是类似，只是将其扩大到对应倍数。 叉积对于两个向量所围成的面积来说，可以使用行列式计算，将两个向量看作是变换后的基向量，这样通过行列式就可以得到变换后面积缩放的比例，因为基向量的单位为1，所以就得到了对应的面积。 考虑到正向，这个面积的值存在负值，这是参照基向量$\\vec i$和$\\vec j$的相对位置来说的。 真正的叉积是通过两个三维向量$\\vec v$和$\\vec w$，生成一个新的三维向量$\\vec u$，这个向量垂直于向量$\\vec v$和$\\vec w$所在的平面，长度等于它们围成的面积。 叉积的反向可以通过右手定则判断： 叉积的计算方法： 线性代数看叉积参考二维向量的叉积计算： 三维的可以写成类似的形式，但是他并是真正的叉积，不过和真正的叉积已经很接近了。 我可以构造一个函数，它可以把一个三维空间映射到一维空间上。 右侧行列式是线性的，所以我们可以找到一个线性变换代替这个函数。 根据对偶性的思想，从多维空间到一维空间的线性变换，等于与对应向量的点积，这个特殊的向量$\\vec p$就是我们要找的向量。 从数值计算上: 向量$\\vec p$的计算结果刚好和叉积计算的结果相同。 从几何意义： 当向量$\\vec p$和向量$\\begin{bmatrix}x\\y\\z \\end{bmatrix}$点乘时，得到一个$\\begin{bmatrix}x\\y\\z \\end{bmatrix}$与$\\vec v$与$\\vec w$确定的平行六面体的有向体积，什么样的向量满足这个性质呢？ 点积的几何解释是，其他向量在$\\vec p$上的投影的长度乘以$\\vec p$的长度。 对于平行六面体的体积来说，它等于$\\vec v$和$\\vec w$所确定的面积乘以$\\begin{bmatrix}x\\y\\z \\end{bmatrix}$在垂线上的投影。 那么$\\vec p$要想满足这一要求，那么它就刚好符合，长度等于$\\vec v,\\vec w$所围成的面积，且刚好垂直这个平面。 基变换标准坐标系的基向量为$\\vec {i}: \\begin{bmatrix}1\\\\0 \\end{bmatrix}$和$\\vec {j}: \\begin{bmatrix}0\\\\1 \\end{bmatrix}$，假如詹妮弗有另一个坐标系：她的基向量为$\\vec i \\begin{bmatrix}2\\\\1 \\end{bmatrix}$和$\\vec j \\begin{bmatrix}-1\\\\1 \\end{bmatrix}$。 对于同一个点$\\begin{bmatrix}3\\\\2 \\end{bmatrix}$来说他们所表示的形式不同，在詹妮弗的坐标系中表示为$\\begin{bmatrix}\\frac{5}{3}\\\\\\frac{1}{3} \\end{bmatrix}$。 从标准坐标到詹尼佛的坐标系，我能可以得到一个线性变换$A:\\begin{bmatrix}2&amp;-1\\\\1&amp;1 \\end{bmatrix}$。 如果想知道詹妮弗的坐标系中点$\\begin{bmatrix}3\\\\2 \\end{bmatrix}$在标准坐标系的位置，可以通过$\\begin{bmatrix}2&amp;-1\\\\1&amp;1 \\end{bmatrix}\\begin{bmatrix}3\\\\2 \\end{bmatrix}$得到。 如果想知道标准坐标系中点$\\begin{bmatrix}3\\\\2 \\end{bmatrix}$在詹妮弗坐标系的位置，可以通过$\\begin{bmatrix}2&amp;-1\\\\1&amp;1 \\end{bmatrix}^{-1}\\begin{bmatrix}3\\\\2 \\end{bmatrix}$得到。 具体的例子，90°旋转。 在标准坐标系可以跟踪基向量的变化来体现： 在詹妮弗的坐标系中如何表示旋转呢？首先将向量转换为标准坐标系的表示，然后左旋，最后再转换为詹妮弗的表示。 所以我们可以得到对于詹妮弗坐标系的左旋线性变化的表示： 所以表达式$A^{-1}MA$表示一种数学上的转移作用，$M$表示一种线性变换，$A$和$A^{-1}$表示坐标系的转换。 特征向量与特征值对于一些线性变化来说，存在一些向量在变换前后留在了张成的空间里，只是拉伸或收缩了一定比例，这些向量称为特征向量，拉伸收缩的比例称为特征值。 一个三维空间的旋转，如果能找到特征值为1的特征向量，那么它就是旋转轴，因为旋转并不进行缩放，且旋转轴在线性变换中保持不变。 特征向量的求解 特征向量的概念，等号左侧表示矩阵向量的乘积，等号右侧表示向量数乘，可以将右侧重写为某个向量的乘积，$\\vec I$为单位向量。 求解等式，就是使左侧的行列式det为0，$\\lambda$就是特征值。 求解$\\lambda$对应的特征向量时，即求解满足$(A-\\lambda I)\\vec{X}=0$的所有向量$\\vec{X}$。 对应原始矩阵上所有落在$\\begin{bmatrix} -1 \\ 1 \\end{bmatrix}$的向量被拉伸了2倍。 二维线性变换不一定存在特征向量，例如左旋90°，每个想都都发生了旋转，离开了张成空间。如果强行计算，会得到两个虚根： 剪切变换的特征向量分布在x轴： 只有一个特征值，但是特征向量不一定只在一条直线上： 特征基 一组基向量构成的集合被称为一组特征基 如果特征向量是基向量，它对应的矩阵是一个对角矩阵，矩阵的对角元是它们所属的特征值。 对角矩阵在求幂次时更方便求解，对应的幂次就是对角元的幂次。 而对于非对角矩阵的幂次求解就非常麻烦。 实际遇到对角矩阵的概率很低，但是我们可以通过基坐标变换来得到对角矩阵，前提有足够多的特征向量且可以张成整个空间，例如剪切变化就不行，应为它只有一个特征向量，无法进行坐标变换。 求解特征值： $\\begin{bmatrix}-\\lambda&amp;1\\1&amp;1-\\lambda \\end{bmatrix}\\vec{X}=0$ $$ \\begin{bmatrix}-\\lambda&1\\\\1&1-\\lambda \\end{bmatrix}\\vec{X}=0 \\\\ \\lambda=\\frac{1+\\sqrt{5}}{2},\\frac{1-\\sqrt{5}}{2} \\\\ 将\\lambda带入求导特征向量为:\\vec{v_1}=\\begin{bmatrix}2\\\\1+\\sqrt{5}\\end{bmatrix},\\vec{v_2}=\\begin{bmatrix}2\\\\1-\\sqrt{5}\\end{bmatrix}\\\\ 所以特征基为：P = \\begin{bmatrix}2&2\\\\1+\\sqrt{5}&1-\\sqrt{5}\\end{bmatrix}\\\\ P^{-1}=\\frac{1}{4\\sqrt{5}}\\begin{bmatrix}\\sqrt{5}-1&2\\\\\\sqrt{5}+1&-2\\end{bmatrix}\\\\ 构造对角矩阵：M=P^{-1}AP=\\frac{1}{2}\\begin{bmatrix}7+3\\sqrt{5}&0\\\\0&7-3\\sqrt{5}\\end{bmatrix}\\\\ A=PMP^{-1}\\\\ A^{n}=PMP^{-1}PMP^{-1}...PMP^{-1}=PM^{n}P^{-1} $$ 抽象向量空间线性的严格定义是：可加性和成比例性。 和函数的求导类似，求导具有可加性和成比例性。 对于多项式的求导，我们也可以看成是矩阵的形式，将x的不同次幂看成基函数，这和多维空间的基向量类似。 因为求导的可加性和成比例行，我们可以分别对每个基向量求导，从而得到左侧的矩阵。 数学中有很多类似向量的事物，只要处理的对象具有数乘和相加的概念，都可以运行向量的基本性质。 对于发明向量的数学家来说，他不用考虑其他所有类似的向量，他只需要给出向量数乘和加法必须遵守的规则即定理，那么所有满足这些定理的对象，就可以使用向量所拥有的性质。","link":"/img/Blog/LinearAlgebra.html"}]}